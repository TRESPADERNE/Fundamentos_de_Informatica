{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Grado en Ingenier\u00eda Biom\u00e9dica","text":""},{"location":"index.html#departamento-de-ingenier\u00eda-de-sistemas-y-autom\u00e1tica-eii-universidad-de-valladolid","title":"Departamento de Ingenier\u00eda de Sistemas y Autom\u00e1tica. EII. Universidad de Valladolid","text":""},{"location":"index.html#fundamentos-de-inform\u00e1tica","title":"Fundamentos de Inform\u00e1tica","text":"<ul> <li>Tema 1: Lenguajes de Programaci\u00f3n</li> <li>Tema 2: Representaci\u00f3n de la Informaci\u00f3n</li> </ul>"},{"location":"Arquitectura_de_computadores.html","title":"Introducci\u00f3n a la Arquitectura de Computadores","text":""},{"location":"Arquitectura_de_computadores.html#\u00edndice","title":"\u00cdndice","text":"<ol> <li>Introducci\u00f3n</li> <li>Estructura de un computador: enfoque multinivel</li> <li>Organizaci\u00f3n y funcionamiento de la CPU</li> <li>El repertorio de instrucciones (ISA)</li> <li>El rendimiento de un computador</li> <li>La memoria</li> <li>Interrupciones</li> <li>Dispositivos de Entrada/Salida</li> <li>Bibliograf\u00eda</li> </ol>"},{"location":"Arquitectura_de_computadores.html#1-introducci\u00f3n","title":"1. Introducci\u00f3n","text":"<p>En 1945 John Von Neumann public\u00f3 un modelo de arquitectura de computador que sigue hoy en d\u00eda siendo la base de la mayor parte de las arquitecturas de computador actuales.</p> <p>La arquitectura Von Neumann distingue tres bloques funcionales fundamentales: *   El procesador o CPU (Central Processing Unit) Ejecuta los programas. *   La memoria Contiene datos e instrucciones, que pueden ser le\u00eddos y escritos.     *   valores, como peso, volumen, sueldo, velocidad, cantidades, nombres, fechas, etc. y direcciones de memoria.     *  instrucciones para procesar esos valores. *   Dispositivos de entrada/salida Suministran al computador los datos que debe procesar y reciben los resultados.</p> <p>Estos bloques funcionales se interconectan a trav\u00e9s del bus del sistema, conjunto de conductores el\u00e9ctricos que transmiten: * las direcciones de memoria para acceder a los datos, * los propios datos (instrucciones y valores) y * las se\u00f1ales de control.</p> <p></p> Figura 1.1 - Bloques funcionales de la arquitectura Von Neumann.(Fuente: https://es.wikipedia.org/wiki/Arquitectura_de_Von_Neumann) <p></p> <p>Las caracter\u00edsticas fundamentales de la arquitectura Von Neumann son: 1.  Valores e instrucciones se almacenan en la misma memoria (programa almacenado).  2.  El contenido de la memoria se organiza en celdas, que son accesibles (lectura y escritura) proporcionando una direcci\u00f3n. 3.  La ejecuci\u00f3n de los programas se realiza por defecto de forma secuencial, una lista consecutiva de instrucciones que se ejecutan una tras otra.</p> <p>El cuello de botella de Von Neumann</p> <p>Valores e instrucciones comparten el bus de datos para ser transferidos a la CPU. Como consecuencia, el procesador no puede acceder simult\u00e1neamente a las instrucciones y a los datos, lo que genera una restricci\u00f3n en el rendimiento conocida como el cuello de botella de Von Neumann. En la pr\u00e1ctica, esto significa que la velocidad del sistema est\u00e1 limitada por el ancho de banda del bus de memoria, que suele ser mucho m\u00e1s lento que la velocidad de procesamiento de la CPU.</p>"},{"location":"Arquitectura_de_computadores.html#11-programaci\u00f3n-cableada-frente-a-programaci\u00f3n-software","title":"1.1 Programaci\u00f3n cableada frente a programaci\u00f3n software","text":"<ul> <li>Programa cableado Mediante la combinaci\u00f3n de componentes l\u00f3gicos es factible recrear funciones que, a partir de unos datos de entrada, permitan obtener las salidas correspondientes. El proceso de dise\u00f1o y posterior interconexi\u00f3n de estos componentes para lograr efectuar un c\u00e1lculo determinado es de hecho una forma de programaci\u00f3n, es un programa cableado.</li> <li>Programa software Para dotar de un prop\u00f3sito general a un dispositivo, la alternativa es utilizar una combinaci\u00f3n de componentes que implementen diversas operaciones b\u00e1sicas l\u00f3gico/aritm\u00e9ticas. Esto permite ejecutar diferentes funciones seg\u00fan se apliquen diferentes se\u00f1ales de control sobre los datos de entrada. Se asocia a cada operaci\u00f3n b\u00e1sica un c\u00f3digo y se a\u00f1ade un hardware que, en funci\u00f3n del c\u00f3digo recibido, genera las se\u00f1ales de control asociadas. Para recrear un c\u00e1lculo o algoritmo determinado, basta determinar la secuencia de c\u00f3digos adecuada. Esta secuencia de c\u00f3digos o instrucciones es el programa software.</li> </ul> Figura 1.2 - Programaci\u00f3n cableada frente a programaci\u00f3n software.(Fuente: W. Stallings. Organizaci\u00f3n y arquitectura de computadores, p\u00e1g. 59) <p>Las dos cajas mostradas en la figura 1.2.b se corresponden con la CPU: bloque funcional formado por el int\u00e9rprete de instrucciones, la Unidad de Control (CU), y el m\u00f3dulo de uso general que implementa las funciones aritm\u00e9ticas y l\u00f3gicas, la Unidad Aritm\u00e9tico L\u00f3gica (ALU).</p> <p>Faltan dos elementos esenciales para que el sistema software pueda funcionar: * M\u00f3dulo de Entrada/Salida: los datos e instrucciones deben introducirse en el sistema con alg\u00fan componente que transforme los formatos de entrada a los formatos que utilice el sistema. Del mismo modo, los resultados deben poder ser accesibles desde el exterior. * La memoria principal: es un componente que en la arquitectura Von Neumann sirve de almac\u00e9n tanto de las instrucciones como de los datos durante la ejecuci\u00f3n del programa. Aunque, a priori, ser\u00eda factible para c\u00e1lculos simples proporcionar secuencialmente las instrucciones y datos seg\u00fan se vayan ejecutando (es lo que se hace formalmente con una calculadora de bolsillo), de forma general, un c\u00e1lculo complejo no siempre ejecutar\u00e1 las instrucciones siguiendo la secuencia predeterminada, pudiendo hacer saltos hacia adelante y hacia atr\u00e1s. Adem\u00e1s, durante el proceso pueden generarse operandos intermedios que se utilizar\u00e1n m\u00e1s adelante y que, por tanto, necesitan ser almacenados temporalmente. </p>"},{"location":"Arquitectura_de_computadores.html#2-estructura-de-un-computador-enfoque-multinivel","title":"2. Estructura de un computador: enfoque multinivel","text":"Figura 2.1 \u2013 Enfoque multinivel de un computador(Fuente: A. Tanembaum. Organizaci\u00f3n de computadoras. Un enfoque estructurado, p\u00e1g. 5) <p>El enfoque multinivel considera al computador estructurado en niveles.</p>"},{"location":"Arquitectura_de_computadores.html#21-nivel-0-l\u00f3gica-digital","title":"2.1 Nivel 0: L\u00f3gica digital","text":"<p>Es el hardware de la m\u00e1quina, donde encontramos compuertas l\u00f3gicas formadas por transistores y las l\u00edneas el\u00e9ctricas que las conectan. Las compuertas l\u00f3gicas son circuitos digitales que implementan funciones booleanas, es decir, funciones con entradas y salidas en el conjunto de valores {0, 1}. Ejemplos b\u00e1sicos son las compuertas que implementan las operaciones AND y OR.</p> <p>Tablas de verdad El funcionamiento de un tipo de compuerta se modela por su tabla de verdad: nos muestra la salida de la compuerta para cada combinaci\u00f3n de entradas posible. En general, para una funci\u00f3n booleana de \\(n\\) entradas tenemos una tabla de \\(2^n\\) filas.</p> <p></p> Figura 2.2 \u2013 Compuerta l\u00f3gica AND formada por transistores(Fuente: https://es.wikipedia.org/wiki/Puerta_l\u00f3gica) <p></p>"},{"location":"Arquitectura_de_computadores.html#22-nivel-1-microarquitectura","title":"2.2 Nivel 1: Microarquitectura","text":"<p>Detalla c\u00f3mo est\u00e1n conectados e interact\u00faan entre s\u00ed los dispositivos del nivel 0 y como se organizan formando unidades funcionales. Aqu\u00ed se decide qu\u00e9 se\u00f1ales de control se utilizar\u00e1n, las interfaces con los dispositivos de E/S, las tecnolog\u00edas de memoria utilizadas, etc.</p> <p>Desde el punto de vista de un programador, la organizaci\u00f3n no es visible.</p> <p>Una instrucci\u00f3n de multiplicar puede llevarse a cabo en el nivel de microarquitectura con un circuito integrado (chip) especializado o con un microprograma interno que realiza de forma iterada sumas.</p> <p></p> Figura 2.3 - Microarquitectura del Intel 80286(Fuente: hhttps://en.wikipedia.org/wiki/Microarchitecture) <p></p>"},{"location":"Arquitectura_de_computadores.html#23-nivel-2-arquitectura-del-conjunto-de-instrucciones-isa","title":"2.3 Nivel 2: Arquitectura del Conjunto de instrucciones (ISA)","text":"<p>El acr\u00f3nimo ISA: Instruction Set Architecture es una especificaci\u00f3n que define el conjunto o repertorio de todas las instrucciones disponibles para una familia de dise\u00f1os de microarquitecturas compatibles.</p> <p>Aunque depende de la bibliograf\u00eda, el conjunto formado por la ISA y la microarquitectura se conoce como la arquitectura de un computador. Como es l\u00f3gico, el dise\u00f1o del repertorio de instrucciones y la microarquitectura asociada est\u00e1n \u00edntimamente ligados.</p>"},{"location":"Arquitectura_de_computadores.html#24-nivel-3-sistema-operativo","title":"2.4 Nivel 3: Sistema Operativo","text":"<p>Un Sistema Operativo act\u00faa como interfaz entre el usuario y el hardware del computador. El sistema operativo es un conjunto de programas que interpretan complejas instrucciones que: * asignan y gestionan los recursos del computador * controlan los programas de los usuarios y las operaciones de E/S. </p> <p>Las instrucciones ISA tambi\u00e9n son accesibles desde este nivel.</p> <p>El S.O. extiende el repertorio de instrucciones de la ISA con llamadas al sistema (System Calls). Para un programador de nivel 3, una instrucci\u00f3n para escribir en un archivo es tan b\u00e1sica como una suma, aunque por debajo implique miles de operaciones.</p> <p></p> Figura 2.4 \u2013 Logos de algunos Sistemas Operativos actuales <p></p>"},{"location":"Arquitectura_de_computadores.html#25-niveles-4-y-5-lenguajes-ensamblador-y-alto-nivel","title":"2.5 Niveles 4 y 5: Lenguajes ensamblador y alto nivel","text":"<p>Ya hemos hablado de ellos en temas anteriores. Los niveles 1 al 3 son utilizados por los programadores de sistemas, es decir, los encargados de dise\u00f1ar y/o implementar programas tales como Sistemas Operativos, Compiladores, Controladores de Dispositivos, etc.</p> <p>Los niveles 4 y particularmente el 5 son utilizados por los programadores de aplicaciones, tales como procesadores de texto, aplicaciones de contabilidad, p\u00e1ginas web, etc.</p>"},{"location":"Arquitectura_de_computadores.html#3-organizaci\u00f3n-y-funcionamiento-de-la-cpu","title":"3. Organizaci\u00f3n y funcionamiento de la CPU","text":""},{"location":"Arquitectura_de_computadores.html#31-introducci\u00f3n","title":"3.1 Introducci\u00f3n","text":"<p>Un procesador debe realizar 5 tareas: captar instrucciones, interpretarlas, captar datos, procesar datos y escribir datos.</p> <p>[Figura 3.1 - El procesador (Esquema interno)]</p> <p>Componentes b\u00e1sicos: 1.  Unidad de Control (CU): Decodifica, secuencia transferencias y controla la ALU. 2.  Unidad Aritm\u00e9tico L\u00f3gica (ALU): Realiza operaciones aritm\u00e9tico-l\u00f3gicas. 3.  Registros: Almacenamiento temporal interno. 4.  Buses: Canales de comunicaci\u00f3n interna.</p> <p>[Figura 3.2 \u2013 Representaci\u00f3n esquem\u00e1tica de la ALU]</p>"},{"location":"Arquitectura_de_computadores.html#los-registros","title":"Los Registros","text":"<ul> <li>Visibles por el usuario: Permiten minimizar accesos a memoria (generalmente 32 o 64 bits).</li> <li>De control y de estado:<ul> <li>PC (Program Counter): Direcci\u00f3n de la siguiente instrucci\u00f3n.</li> <li>IR (Instruction Register): Instrucci\u00f3n captada m\u00e1s recientemente.</li> <li>PSW (Program Status Word): Bits indicadores (Signo, Cero, Acarreo, etc.).</li> </ul> </li> </ul>"},{"location":"Arquitectura_de_computadores.html#los-buses","title":"Los Buses","text":"<p>Agrupaci\u00f3n de conductores para intercambio de informaci\u00f3n. El bus del sistema incluye: bus de direcciones, bus de datos y bus de control.</p>"},{"location":"Arquitectura_de_computadores.html#32-el-ciclo-de-instrucci\u00f3n","title":"3.2 El ciclo de instrucci\u00f3n","text":"<p>Pasos b\u00e1sicos: 1.  Captaci\u00f3n (fetch): Se obtiene la instrucci\u00f3n de memoria (usando el PC) y se guarda en el IR. Se incrementa el PC. 2.  Decodificaci\u00f3n (decode): La UC interpreta el c\u00f3digo binario. 3.  Ejecuci\u00f3n (execute): Se leen operandos, se opera y se almacenan resultados.</p> <p>[Figura 3.3 \u2013 El ciclo de instrucci\u00f3n (Diagrama)]</p>"},{"location":"Arquitectura_de_computadores.html#4-el-repertorio-de-instrucciones-isa","title":"4. El repertorio de instrucciones (ISA)","text":"<p>Describe los aspectos del procesador visibles para el programador de sistemas: tipos de formatos, tipos de datos y n\u00famero de registros.</p>"},{"location":"Arquitectura_de_computadores.html#41-tipos-de-instrucciones","title":"4.1 Tipos de instrucciones","text":"<ul> <li>Transformaci\u00f3n: Operaciones sobre datos.</li> <li>Transferencia: Copia de datos (Memoria \\(\\leftrightarrow\\) Registros, etc.).</li> <li>Control del flujo: Saltos en la ejecuci\u00f3n.</li> <li>Control del procesador: Cambio de modo de funcionamiento.</li> </ul>"},{"location":"Arquitectura_de_computadores.html#42-codificaci\u00f3n-y-formatos","title":"4.2 Codificaci\u00f3n y formatos","text":"<p>Un formato de instrucci\u00f3n incluye el opcode (operaci\u00f3n) y los campos de direccionamiento (operandos).</p> <p>[Figura 4.1 \u2013 Formato de una instrucci\u00f3n]</p>"},{"location":"Arquitectura_de_computadores.html#43-clasificaci\u00f3n-de-arquitecturas","title":"4.3 Clasificaci\u00f3n de arquitecturas","text":"<p>Seg\u00fan el almacenamiento de operandos: 1.  Pila: Operandos impl\u00edcitos. 2.  Acumulador: Un operando es siempre el registro acumulador. 3.  GPR (Registros de prop\u00f3sito general):     *   Memoria-Registro: Un operando puede estar en memoria.     *   Registro-Registro (RISC): Operandos solo en registros. Solo <code>LOAD</code> y <code>STORE</code> acceden a memoria.</p> <p>[Figura 4.2 \u2013 Situaci\u00f3n de los operandos para cuatro tipos de arquitecturas]</p>"},{"location":"Arquitectura_de_computadores.html#5-el-rendimiento-de-un-computador","title":"5. El rendimiento de un computador","text":"<p>Se define como la capacidad para ejecutar programas en el menor tiempo posible.</p>"},{"location":"Arquitectura_de_computadores.html#51-el-reloj","title":"5.1 El reloj","text":"<p>Sincroniza las operaciones. La frecuencia (Hz) es la referencia de rendimiento.</p> <p>[Figura 5.1 \u2013 Oscilador de cristal y generador de reloj] [Figura 5.2 \u2013 Se\u00f1al de onda rectangular]</p> <p>F\u00f3rmula de tiempo de CPU: $\\(\\text{Tiempo de CPU} = \\text{N\u00famero de instrucciones} \\times \\text{CPI} \\times \\text{Tiempo de ciclo}\\)$</p>"},{"location":"Arquitectura_de_computadores.html#52-paralelismo-procesadores-multinucleo","title":"5.2 Paralelismo: procesadores multinucleo","text":"<p>Varios n\u00facleos en un mismo chip para ejecutar procesos o hilos (threads) concurrentemente.</p> <p>[Figura 5.3 \u2013 Frecuencia y Potencia de procesadores Intel x86 (30 a\u00f1os)] [Figura 5.4 \u2013 Sistema de refrigeraci\u00f3n de una CPU]</p>"},{"location":"Arquitectura_de_computadores.html#53-segmentaci\u00f3n-de-instrucciones-pipelining","title":"5.3 Segmentaci\u00f3n de instrucciones (Pipelining)","text":"<p>Divide la ejecuci\u00f3n en etapas (ej. IF, ID, EX, MEM, WB) para procesar varias instrucciones a la vez.</p> <p>[Figura 5.5 \u2013 Tiempos de ejecuci\u00f3n de las etapas para diferentes tipos de instrucci\u00f3n] [Figura 5.6 \u2013 Comparaci\u00f3n de ciclo simple frente a segmentaci\u00f3n]</p>"},{"location":"Arquitectura_de_computadores.html#6-la-memoria","title":"6. La memoria","text":"<p>Organizada jer\u00e1rquicamente para equilibrar coste, capacidad y velocidad.</p>"},{"location":"Arquitectura_de_computadores.html#61-tipos-de-memorias","title":"6.1 Tipos de memorias","text":"<ul> <li>Vol\u00e1tiles: SRAM (cach\u00e9, r\u00e1pida) y DRAM (memoria principal, lenta pero densa).</li> <li>No vol\u00e1tiles: ROM, PROM, EPROM, EEPROM y Memoria Flash.</li> <li>Secundaria: Discos duros, SSD, etc.</li> </ul> <p>[Figura 6.1 \u2013 Tecnolog\u00eda de almacenamiento secundario obsoleta]</p>"},{"location":"Arquitectura_de_computadores.html#62-la-jerarqu\u00eda-de-memoria","title":"6.2 La jerarqu\u00eda de memoria","text":"<p>Basada en los principios de localidad temporal (reuso de datos) y localidad espacial (datos cercanos en memoria).</p> <p>[Figura 6.2 \u2013 Fragmentos de c\u00f3digo con buena/mala localidad espacial] [Figura 6.3 \u2013 La pir\u00e1mide de la jerarqu\u00eda de memoria] [Figura 6.4 \u2013 Intercambios de datos entre niveles (palabras, bloques, p\u00e1ginas)]</p>"},{"location":"Arquitectura_de_computadores.html#63-la-memoria-cach\u00e9","title":"6.3 La memoria cach\u00e9","text":"<p>Memoria peque\u00f1a y r\u00e1pida entre la CPU y la RAM. *   Conceptos: Hit (acierto), Miss (fallo), Ancho de banda y Latencia. *   Pol\u00edticas de ubicaci\u00f3n: Directa, Asociativa y Asociativa por conjuntos.</p> <p>[Figura 6.5 \u2013 Principio de funcionamiento de una cach\u00e9] [Figura 6.6 \u2013 Jerarqu\u00eda cach\u00e9 en un Intel Core i7]</p>"},{"location":"Arquitectura_de_computadores.html#64-la-arquitectura-harvard","title":"6.4 La arquitectura Harvard","text":"<p>Usa memorias y buses f\u00edsicamente separados para instrucciones y datos. Ventaja: acceso simult\u00e1neo.</p> <p>[Figura 6.7 \u2013 Comparativa Von Neumann vs Harvard] [Figura 6.8 \u2013 Arquitectura Harvard en microcontrolador Arduino]</p>"},{"location":"Arquitectura_de_computadores.html#7-interrupciones","title":"7. Interrupciones","text":"<p>Alteraci\u00f3n forzada del flujo de ejecuci\u00f3n ante un evento. Incluye un n\u00famero de interrupci\u00f3n (IRQ) y una rutina de servicio (ISR).</p> <p>[Figura 7.1 \u2013 Ciclo de instrucci\u00f3n con interrupciones]</p> <ul> <li>Tipos: Hardware (as\u00edncronas), Llamadas al sistema (traps) y Excepciones (errores).</li> </ul>"},{"location":"Arquitectura_de_computadores.html#8-dispositivos-de-entradasalida","title":"8. Dispositivos de Entrada/Salida","text":""},{"location":"Arquitectura_de_computadores.html#81-m\u00f3dulos-de-es","title":"8.1 M\u00f3dulos de E/S","text":"<p>Act\u00faan como interfaz para gestionar la diversidad de perif\u00e9ricos y velocidades.</p> <p>[Figura 8.1 \u2013 Diagrama de bloques de un m\u00f3dulo de E/S]</p>"},{"location":"Arquitectura_de_computadores.html#82-buses-de-es","title":"8.2 Buses de E/S","text":"<p>Est\u00e1ndares actuales: USB (prop\u00f3sito general), PCIe (alta velocidad/tarjetas), SPI (baja velocidad/sensores) y SATA (almacenamiento).</p> <p>[Figura 8.2 \u2013 Componentes de una placa base] [Figura 8.3 \u2013 Diagrama de bloques del chipset Intel Z690]</p>"},{"location":"Arquitectura_de_computadores.html#84-t\u00e9cnicas-de-sincronizaci\u00f3n","title":"8.4 T\u00e9cnicas de sincronizaci\u00f3n","text":"<ol> <li>Sondeo (Polling): La CPU consulta peri\u00f3dicamente el estado.</li> <li>Interrupci\u00f3n: El dispositivo avisa a la CPU cuando est\u00e1 listo.</li> </ol> <p>[Figura 8.4 \u2013 Diagramas de flujo de sondeo continuo y peri\u00f3dico] [Figura 8.5 \u2013 Sincronizaci\u00f3n mediante interrupciones]</p>"},{"location":"Arquitectura_de_computadores.html#85-transferencia-de-datos","title":"8.5 Transferencia de datos","text":"<ul> <li>Por programa: La CPU mueve los datos uno a uno.</li> <li>DMA (Direct Memory Access): Un controlador especializado mueve bloques de datos entre perif\u00e9rico y memoria sin usar la CPU.</li> </ul> <p>[Figura 8.6 \u2013 Transferencias de datos entre disco y memoria: PIO vs DMA]</p>"},{"location":"Arquitectura_de_computadores.html#bibliograf\u00eda","title":"Bibliograf\u00eda","text":"<p>(Listado de referencias del documento original)</p>"},{"location":"Lenguajes_de_programacion.html","title":"Lenguajes de Programaci\u00f3n","text":""},{"location":"Lenguajes_de_programacion.html#\u00edndice","title":"\u00cdndice","text":"<ol> <li>Introducci\u00f3n a los lenguajes de programaci\u00f3n</li> <li>Niveles de Abstracci\u00f3n</li> <li>Paradigmas y Panorama Actual</li> <li>Compiladores (El modelo C/C++)</li> <li>Int\u00e9rpretes y M\u00e1quinas Virtuales</li> <li>Compiladores frente a Int\u00e9rpretes</li> <li>Ecosistema de Desarrollo (IDEs)</li> <li>\u00c9tica y Responsabilidad en la Era de la IA</li> </ol>"},{"location":"Lenguajes_de_programacion.html#1-introducci\u00f3n-a-los-lenguajes-de-programaci\u00f3n","title":"1. Introducci\u00f3n a los lenguajes de programaci\u00f3n","text":""},{"location":"Lenguajes_de_programacion.html#concepto-b\u00e1sico","title":"Concepto B\u00e1sico","text":"<p>Los programadores escriben programas utilizando lenguajes de programaci\u00f3n para que el ordenador ejecute una serie de instrucciones. Estos programas legibles por humanos se denominan c\u00f3digo fuente.</p> <p>Por otro lado, el ordenador (el hardware) trabaja internamente usando exclusivamente c\u00f3digo binario (secuencias de 0s y 1s que representan estados f\u00edsicos de voltaje), un formato que resulta ininteligible a primera vista para las personas. El c\u00f3digo binario ejecutable de un programa se denomina c\u00f3digo objeto o c\u00f3digo m\u00e1quina.</p> <p>Por tanto, se deduce la necesidad de utilizar programas traductores que conviertan el c\u00f3digo fuente (alto nivel de abstracci\u00f3n) a c\u00f3digo m\u00e1quina (bajo nivel de abstracci\u00f3n).</p>"},{"location":"Lenguajes_de_programacion.html#definici\u00f3n-y-componentes","title":"Definici\u00f3n y Componentes","text":"<p>Un Lenguaje de Programaci\u00f3n es un conjunto de s\u00edmbolos y reglas con los que expresar \u00f3rdenes a un ordenador.</p> <ol> <li>L\u00e9xico: El conjunto de s\u00edmbolos (palabras, signos de puntuaci\u00f3n) que acepta el lenguaje.</li> <li>Sintaxis: Reglas que establecen qu\u00e9 construcciones son aceptables como instrucciones v\u00e1lidas (la gram\u00e1tica).</li> <li>Sem\u00e1ntica: Reglas que establecen el significado o comportamiento de dichas instrucciones.</li> </ol> <p>Diferencia clave entre Sintaxis y Sem\u00e1ntica:</p> <ul> <li>Ejemplo en lenguaje natural: La frase \"La silla come manzanas\" es sint\u00e1cticamente correcta (Sujeto + Verbo + Predicado), pero sem\u00e1nticamente incorrecta (carece de sentido l\u00f3gico).</li> <li>Ejemplo en programaci\u00f3n (Python): La instrucci\u00f3n <code>resultado = \"Hola\" / 2</code> es sint\u00e1cticamente correcta (estructura v\u00e1lida: variable = valor / valor), pero sem\u00e1nticamente err\u00f3nea (no tiene sentido l\u00f3gico ni matem\u00e1tico dividir un texto (<code>\"Hola\"</code>) entre un n\u00famero (<code>2</code>).</li> </ul>"},{"location":"Lenguajes_de_programacion.html#comparativa-lenguaje-natural-vs-programaci\u00f3n","title":"Comparativa: Lenguaje Natural vs. Programaci\u00f3n","text":"Caracter\u00edstica Lenguaje Natural (Humano) Lenguaje de Programaci\u00f3n L\u00e9xico Palabras y signos de puntuaci\u00f3n. S\u00edmbolos reservados del lenguaje (palabras clave, operadores). Sintaxis Oraciones gramaticalmente correctas. Instrucciones bien formadas y v\u00e1lidas. Sem\u00e1ntica Informaci\u00f3n o mensaje que transmite quien habla. Qu\u00e9 acciones exactas debe ejecutar el hardware. Ambig\u00fcedad Alta (depende del contexto). Nula (una instrucci\u00f3n debe tener una \u00fanica interpretaci\u00f3n)."},{"location":"Lenguajes_de_programacion.html#2-niveles-de-abstracci\u00f3n","title":"2. Niveles de Abstracci\u00f3n","text":"<p>El concepto de abstracci\u00f3n en inform\u00e1tica se refiere a la capacidad de ocultar la complejidad interna del hardware para facilitar la programaci\u00f3n. Cuanto mayor es el nivel de abstracci\u00f3n de un lenguaje, m\u00e1s nos alejamos de los detalles f\u00edsicos de la m\u00e1quina (transistores, registros, direcciones de memoria) para centrarnos en la l\u00f3gica del problema a resolver (f\u00f3rmulas, objetos, datos).</p> <p>B\u00e1sicamente se pueden establecer tres niveles de abstracci\u00f3n:</p> <ol> <li>Lenguaje m\u00e1quina (Bajo nivel)</li> <li>Lenguaje ensamblador (Bajo nivel)</li> <li>Lenguajes de Alto nivel</li> </ol>"},{"location":"Lenguajes_de_programacion.html#lenguaje-m\u00e1quina","title":"Lenguaje M\u00e1quina","text":"<p>Es el lenguaje directamente comprensible por el procesador (CPU). En el tema de Arquitectura estudiaremos c\u00f3mo la CPU procesa estas \u00f3rdenes; por ahora basta entender que es el componente hardware encargado de leer secuencialmente unos y ceros y actuar en consecuencia (sumar, guardar datos, etc.).</p> <ul> <li> <p>Utiliza un sistema de codificaci\u00f3n binaria (secuencias de 1's y 0's) para definir un conjunto predefinido de instrucciones, (ISA, Instruction Set Architecture).</p> <p>Definici\u00f3n de instrucci\u00f3n</p> <p>Una instrucci\u00f3n es la operaci\u00f3n m\u00e1s elemental que el hardware puede realizar indivisiblemente, como sumar dos valores, mover un dato de memoria al procesador, etc.</p> </li> <li> <p>Depende totalmente de la arquitectura: un c\u00f3digo m\u00e1quina para una CPU ARM (m\u00f3vil) es incomprensible para una CPU Intel Core i7 (PC).</p> </li> <li> <p>Gesti\u00f3n: A este nivel, el control de la memoria es manual y absoluto.</p> <p>\u00bfQu\u00e9 es la memoria?</p> <p>La memoria es el casillero gigante de celdas numeradas donde se almacenan los datos y el programa en ejecuci\u00f3n. En c\u00f3digo m\u00e1quina no existen las variables con nombres (como <code>edad</code>), sino que el programador a este nivel debe referirse a los datos por su direcci\u00f3n f\u00edsica (el n\u00famero exacto de la celda, ej: <code>0x0045A</code>).</p> </li> </ul>"},{"location":"Lenguajes_de_programacion.html#lenguaje-ensamblador","title":"Lenguaje Ensamblador","text":"<p>Emplea palabras nemot\u00e9cnicas (abreviaturas) para hacer referencia a las instrucciones del lenguaje de m\u00e1quina, haci\u00e9ndolo ligeramente m\u00e1s legible para el humano.</p> <p>Ejemplo de traducci\u00f3n y estructura (Familia x86/IA-32):</p> Lenguaje de m\u00e1quina Ensamblador <code>10110000 01100001</code> <code>MOV AL, 61h</code> <p>En este ejemplo, la instrucci\u00f3n binaria se compone de 3 partes que el hardware decodifica:</p> <ol> <li> <p>C\u00f3digo de operaci\u00f3n (5 primeros bits): La secuencia <code>10110</code> ordena mover (MOV) un dato a un registro.</p> <p>\u00bfQu\u00e9 es un registro?</p> <p>Un registro es una celda de memoria ultrarr\u00e1pida situada dentro de la propia CPU.</p> </li> <li> <p>Registro destino (3 siguientes bits): El c\u00f3digo <code>000</code> corresponde al registro interno denominado AL.</p> </li> <li>Dato (8 bits finales): La secuencia <code>01100001</code> es el valor del dato (97 en decimal, 61 en hexadecimal).</li> </ol> <p>El lenguaje ensamblador permite escribir <code>MOV AL, 61h</code> en lugar de la cadena de bits, resultando mucho m\u00e1s inteligible.</p> <p>Proceso de Traducci\u00f3n: El programa escrito en lenguaje ensamblador (Programa Fuente) debe ser traducido a lenguaje de m\u00e1quina (Programa Objeto), ya que el procesador solo entiende 0s y 1s. Esta tarea la realiza una herramienta llamada Ensamblador.</p> <p><code>[Programa Fuente] --&gt; [Ensamblador] --&gt; [Programa Objeto]</code></p> <p>Caracter\u00edsticas clave:</p> <ul> <li>Traducci\u00f3n directa: Generalmente existe una correspondencia 1 a 1 entre instrucci\u00f3n ensamblador y m\u00e1quina.</li> <li>Dependencia: \u00a1Cada familia de CPU's tiene su propio lenguaje ensamblador!</li> </ul>"},{"location":"Lenguajes_de_programacion.html#lenguajes-de-alto-nivel","title":"Lenguajes de Alto Nivel","text":"<p>Estos lenguajes buscan acercarse a la forma de pensar humana y alejarse del detalle del hardware.</p> <ul> <li>Independencia y Portabilidad: Definen su sintaxis y sus estructuras al margen del procesador que se utilice. Un mismo c\u00f3digo fuente puede ejecutarse en diferentes m\u00e1quinas (es portable), siempre que se traduzca adecuadamente.</li> <li>Correspondencia Compleja (1 a N): A diferencia del ensamblador (1 a 1), una sola sentencia de alto nivel genera m\u00faltiples instrucciones de c\u00f3digo m\u00e1quina.</li> <li>Legibilidad y Edici\u00f3n: Se escriben como texto plano (usando palabras en ingl\u00e9s como <code>if</code>, <code>while</code>) y permiten el uso de comentarios para explicar el c\u00f3digo a otros humanos.</li> <li>Necesidad de Traducci\u00f3n: Para poder ejecutarse, necesitan ser traducidos al lenguaje del procesador mediante Compiladores o Int\u00e9rpretes.</li> <li> <p>Tipado:</p> <ul> <li> <p>Est\u00e1tico (C++, Java): El tipo de dato debe definirse expl\u00edcitamente antes de compilar.</p> <p><code>int x = 3;</code></p> <p>El programador obliga a que <code>x</code> sea un n\u00famero entero.</p> </li> <li> <p>Din\u00e1mico (Python, JS): El tipo se deduce autom\u00e1ticamente durante la ejecuci\u00f3n.</p> <p><code>x = 3</code></p> <p>Python infiere que <code>x</code> es un entero por el literal (<code>3</code>) utilizado, sin necesidad de declararlo.</p> </li> </ul> </li> </ul> <p>Ejemplo Comparativo: <code>\"Hola Mundo\"</code></p> <p>Para visualizar la diferencia de abstracci\u00f3n, veamos c\u00f3mo se imprime un mensaje en pantalla en distintos niveles:</p> Nivel C\u00f3digo Ejemplo Lenguaje M\u00e1quina <code>B8 21 0A 00 00 ...</code> (Secuencia binaria/hexadecimal ininteligible) Ensamblador (x86) <code>MOV EDX, len</code><code>MOV ECX, msg</code><code>MOV EBX, 1</code><code>MOV EAX, 4</code><code>INT 0x80</code> C++ (Alto Nivel) <code>std::cout &lt;&lt; \"Hola Mundo\";</code> Python (Muy Alto Nivel) <code>print(\"Hola Mundo\")</code>"},{"location":"Lenguajes_de_programacion.html#3-paradigmas-y-panorama-actual","title":"3. Paradigmas y Panorama Actual","text":"<p>Un paradigma de programaci\u00f3n describe una forma de realizar los c\u00e1lculos y la manera en que se deben estructurar y organizar las tareas que debe llevar a cabo un programa.</p> <ul> <li>Los lenguajes de programaci\u00f3n suelen implementar, a menudo de forma parcial, varios paradigmas.</li> <li>Entre los diferentes tipos de paradigmas, una divisi\u00f3n b\u00e1sica es dividirlos en imperativos (se detalla c\u00f3mo se realizan los c\u00e1lculos) y declarativos (se indica qu\u00e9 c\u00e1lculos deben realizarse).</li> <li>Otros paradigmas se centran en la estructura y organizaci\u00f3n: programaci\u00f3n estructurada, modular, orientada a objetos, gen\u00e9rica, orientada a eventos, concurrente...</li> </ul> <p>Nota</p> <p>La mejor forma de entender un paradigma es aprender un lenguaje de programaci\u00f3n que lo implemente, por lo que no entraremos en m\u00e1s detalles.</p> <p></p> Clasificaci\u00f3n de los paradigmas de programaci\u00f3n."},{"location":"Lenguajes_de_programacion.html#la-jungla-de-los-lenguajes","title":"La jungla de los lenguajes","text":"<p>A menudo, el panorama actual se percibe como una jungla de lenguajes.</p> <ul> <li>Existen miles de lenguajes (se estima que hay m\u00e1s de 9.000 creados hist\u00f3ricamente).</li> <li>Para un alumno novel, enfrentarse a esta imagen provoca la par\u00e1lisis de la elecci\u00f3n: \u00bfPor cu\u00e1l empiezo? \u00bfCu\u00e1l es el mejor?</li> <li>La realidad: No todos tienen la misma importancia. Muchos son acad\u00e9micos, otros est\u00e1n obsoletos (como el lat\u00edn) y otros son de nicho muy espec\u00edfico.</li> </ul> <p>En esa jungla encontrar\u00e9is herramientas para todo. Python es una navaja suiza (sirve para casi todo, f\u00e1cil de llevar), C++ es un bistur\u00ed l\u00e1ser industrial (muy potente, pero si no sabes usarlo te cortas un brazo), y otros son simplemente juguetes.</p> <p></p> La jungla de lenguajes de programaci\u00f3n."},{"location":"Lenguajes_de_programacion.html#popularidad-y-demanda-rankings","title":"Popularidad y Demanda (Rankings)","text":"<p>Dado el enorme n\u00famero de lenguajes existentes, la industria se gu\u00eda por \u00edndices de popularidad para decidir qu\u00e9 tecnolog\u00edas adoptar. No existe un mejor lenguaje absoluto, pero s\u00ed tendencias de mercado claras. Dos de los indicadores m\u00e1s fiables son:</p> <ol> <li>\u00cdndice TIOBE: Se basa en el n\u00famero de resultados en motores de b\u00fasqueda. Es un buen indicador sobre qu\u00e9 se est\u00e1 hablando o qu\u00e9 se est\u00e1 buscando aprender.</li> <li>Ranking RedMonk: Cruza datos de GitHub (cantidad de c\u00f3digo escrito) y Stack Overflow (cantidad de preguntas t\u00e9cnicas). Es un indicador m\u00e1s preciso de qu\u00e9 se est\u00e1 usando realmente en proyectos.</li> </ol> <p>El declive de Stack Overflow y la era de la IA</p> <p>Stack Overflow ha sido la p\u00e1gina web de referencia absoluta para resolver dudas de programaci\u00f3n durante m\u00e1s de una d\u00e9cada. Sin embargo, su tr\u00e1fico e interacci\u00f3n han sufrido una ca\u00edda significativa con el advenimiento de asistentes de IA generativa (como ChatGPT o GitHub Copilot).</p> <p>Al obtener respuestas inmediatas y c\u00f3digo generado a medida por la IA, muchos desarrolladores ya no acuden a publicar sus dudas en la comunidad. Esto plantea la inc\u00f3gnita de si rankings como RedMonk, que dependen de estos datos, seguir\u00e1n siendo fiables en el futuro cercano.</p> <p></p> Ranking TIOBE: Evoluci\u00f3n hist\u00f3rica de la popularidad. <p></p> Ranking Redmonk: Eje vertical (Popularidad en StackOverflow), Eje horizontal (Proyectos en GitHub)."},{"location":"Lenguajes_de_programacion.html#por-qu\u00e9-python-como-primer-lenguaje-en-ingenier\u00eda","title":"\u00bfPor qu\u00e9 Python como primer lenguaje en Ingenier\u00eda?","text":"<p>Dado que nuestra asignatura se orienta a titulaciones de ingenier\u00eda (Biom\u00e9dica, Electr\u00f3nica, Mec\u00e1nica, Qu\u00edmica, etc.), la elecci\u00f3n de Python como primer lenguaje no es arbitraria y se justifica por varios motivos t\u00e9cnicos y pr\u00e1cticos frente a opciones cl\u00e1sicas como C o C++:</p> <ol> <li> <p>Foco en la resoluci\u00f3n del problema: En ingenier\u00eda, la programaci\u00f3n es una herramienta para resolver problemas (filtrar una se\u00f1al fisiol\u00f3gica, simular una estructura mec\u00e1nica, analizar datos qu\u00edmicos), no un fin en s\u00ed mismo. La sintaxis de Python es limpia y legible (cercana al pseudoc\u00f3digo), lo que reduce la carga cognitiva: el alumno dedica su esfuerzo mental a entender el algoritmo, no a pelear con llaves, puntos y comas o gesti\u00f3n de memoria manual.</p> </li> <li> <p>El est\u00e1ndar en Ciencia de Datos e IA: Python posee el ecosistema de librer\u00edas cient\u00edficas m\u00e1s robusto del mundo.</p> <ul> <li>Biom\u00e9dica: Procesamiento de im\u00e1genes (OpenCV), se\u00f1ales m\u00e9dicas (SciPy, MNE).</li> <li>Mec\u00e1nica/Qu\u00edmica: An\u00e1lisis de datos experimentales (Pandas), simulaci\u00f3n num\u00e9rica (NumPy).</li> <li>Electr\u00f3nica: Control de instrumentos y automatizaci\u00f3n.</li> </ul> </li> <li> <p>Productividad: Un programa en Python suele requerir entre 3 y 5 veces menos l\u00edneas de c\u00f3digo que su equivalente en C++ o Java. Esto permite prototipar soluciones funcionales en mucho menos tiempo.</p> </li> <li> <p>Multiparadigma: Permite empezar programando de forma imperativa (sencilla) y avanzar hacia la orientaci\u00f3n a objetos o funcional progresivamente, sin imponer una estructura r\u00edgida desde la l\u00ednea 1.</p> </li> </ol> <p></p> \u00bfQu\u00e9 lenguaje aprender en primer lugar?"},{"location":"Lenguajes_de_programacion.html#4-compiladores-el-modelo-cc","title":"4. Compiladores (El modelo C/C++)","text":"<p>Un compilador es un programa que traduce todo el c\u00f3digo fuente de una sola vez a un programa equivalente en otro lenguaje (normalmente c\u00f3digo m\u00e1quina) para su posterior ejecuci\u00f3n.</p> <p>Es importante destacar que los compiladores son algunas de las piezas de software m\u00e1s complejas y fascinantes de la inform\u00e1tica. Su construcci\u00f3n requiere una alt\u00edsima capacitaci\u00f3n, ya que act\u00faan como puente entre dos mundos: deben comprender la teor\u00eda matem\u00e1tica del lenguaje formal y, a la vez, explotar al m\u00e1ximo los recursos f\u00edsicos del hardware.</p> <p>El compilador detecta errores en tiempo de compilaci\u00f3n (sintaxis), pero no errores en tiempo de ejecuci\u00f3n (l\u00f3gica).</p>"},{"location":"Lenguajes_de_programacion.html#generaci\u00f3n-del-ejecutable-el-proceso-de-build","title":"Generaci\u00f3n del Ejecutable (El proceso de Build)","text":"<ol> <li>Edici\u00f3n: Se escribe el c\u00f3digo fuente: las extensiones habituales de los archivos son <code>.cpp</code> y <code>.h</code>.</li> <li>Preprocesamiento: Es una fase previa de preparaci\u00f3n del texto. El preprocesador limpia el c\u00f3digo eliminando las notas del autor (comentarios) e incrusta el contenido de ficheros externos necesarios (como si hiciera un copiar y pegar autom\u00e1tico de las bibliotecas), dejando el c\u00f3digo listo para traducir.</li> <li> <p>Compilaci\u00f3n: Traduce el c\u00f3digo preprocesado a c\u00f3digo objeto (<code>.o</code> o <code>.obj</code>). Este c\u00f3digo es binario pero a\u00fan no es ejecutable por s\u00ed mismo porque le faltan las conexiones con el resto del proyecto.</p> <p>Las referencias cruzadas entre unidades de compilaci\u00f3n</p> <p>Un programa suele dividirse en muchos archivos fuente. En esta fase, cada archivo se traduce por separado. Pero si una unidad necesita usar una funci\u00f3n que est\u00e1 escrita en otra unidad de compilaci\u00f3n, todav\u00eda no sabe d\u00f3nde encontrarla. Esas referencias cruzadas est\u00e1n pendientes de resolver.</p> </li> <li> <p>Enlazado (Linker): Une todos los archivos objeto del programador con las bibliotecas externas (ej. funciones matem\u00e1ticas) para crear un \u00fanico fichero ejecutable binario (<code>.exe</code>).</p> </li> </ol> <p>El Cargador (Loader)</p> <p>Cuando un usuario ejecuta ese archivo <code>.exe</code>, un componente del sistema operativo llamado cargador (loader) transfiere el c\u00f3digo y los datos del fichero binario a la memoria RAM, y la CPU comienza a procesar las instrucciones en c\u00f3digo m\u00e1quina que contiene.</p> <p></p> Proceso de compilaci\u00f3n en C++"},{"location":"Lenguajes_de_programacion.html#fases-de-la-traducci\u00f3n-interior-del-compilador","title":"Fases de la Traducci\u00f3n (Interior del Compilador)","text":"<p>El compilador realiza la traducci\u00f3n t\u00edpicamente en 2 grandes fases:</p> <ol> <li>Fase de An\u00e1lisis (Front-end):<ul> <li>L\u00e9xico: Verifica s\u00edmbolos v\u00e1lidos.</li> <li>Sint\u00e1ctico: Verifica la estructura gramatical.</li> <li>Sem\u00e1ntico: Verifica la coherencia de tipos y significado.</li> </ul> </li> <li>Fase de S\u00edntesis (Back-end):<ul> <li>Generaci\u00f3n de c\u00f3digo intermedio.</li> <li>Optimizaci\u00f3n: Fase cr\u00edtica donde el compilador mejora el c\u00f3digo (elimina c\u00f3digo muerto, desenrolla bucles) para reducir tama\u00f1o o aumentar velocidad.</li> <li>Generaci\u00f3n de c\u00f3digo m\u00e1quina espec\u00edfico para la arquitectura.</li> </ul> </li> </ol> <p>Tabla de S\u00edmbolos: Durante todo este proceso, el compilador mantiene una estructura de datos llamada Tabla de S\u00edmbolos. Esta act\u00faa como una base de datos centralizada donde se registra informaci\u00f3n sobre cada identificador encontrado (variables, funciones, tipos), permitiendo verificar, por ejemplo, que no usemos una variable que no ha sido declarada previamente.</p> <p></p> Fases de la traducci\u00f3n de un compilador"},{"location":"Lenguajes_de_programacion.html#importancia-de-la-arquitectura-y-retrocompatibilidad","title":"Importancia de la Arquitectura y Retrocompatibilidad","text":"<p>Dado que cada familia de CPU tiene un conjunto de instrucciones diferente (ISA), es necesario utilizar un compilador adaptado a esa arquitectura espec\u00edfica. Muchas firmas, como Intel, garantizan retrocompatibilidad: c\u00f3digo escrito para sus CPU m\u00e1s antiguas (como la 8086 de los a\u00f1os 70) puede ejecutarse en sus chips modernos (arquitectura x86). Sin embargo, lo opuesto no es cierto: un ejecutable generado aprovechando las caracter\u00edsticas de un chip moderno de 64 bits no funcionar\u00e1 en uno antiguo de 16 bits.</p>"},{"location":"Lenguajes_de_programacion.html#5-int\u00e9rpretes-y-m\u00e1quinas-virtuales","title":"5. Int\u00e9rpretes y M\u00e1quinas Virtuales","text":""},{"location":"Lenguajes_de_programacion.html#int\u00e9rprete-puro","title":"Int\u00e9rprete Puro","text":"<p>A diferencia del compilador, que act\u00faa como un traductor de libros (traduce la obra entera antes de entregarla), el int\u00e9rprete act\u00faa como un traductor simult\u00e1neo: lee una instrucci\u00f3n, la traduce y la ejecuta al vuelo.</p> <p>Ejemplo ilustrativo (Pseudoc\u00f3digo / Python): Imaginemos un programa con un error de sintaxis. <pre><code>a = 10\nb = 20\nprint(a, b)\nc = a + / b   # &lt;--- \u00a1\u00a1ERROR DE SINTAXIS!! (Sobran operadores)\nprint(c)\n</code></pre></p> <ul> <li>Comportamiento Compilado: El proceso de traducci\u00f3n falla antes de empezar (Compilation Error). No se genera ning\u00fan archivo ejecutable y el usuario no ve nada en pantalla.</li> <li> <p>Comportamiento Interpretado: El programa arranca inmediatamente. El usuario ve por la consola los valores de <code>a</code> y <code>b</code> y, justo despu\u00e9s, el programa se estrella (crash) al intentar ejecutar la cuarta l\u00ednea.</p> </li> <li> <p>No genera un ejecutable independiente (como un <code>.exe</code>). Necesitas tener el int\u00e9rprete instalado en la m\u00e1quina para correr el c\u00f3digo.</p> </li> <li>Ventaja: Flexibilidad, depuraci\u00f3n r\u00e1pida, y capacidad de ejecutar c\u00f3digo generado din\u00e1micamente.</li> <li>Desventaja: Menor velocidad de ejecuci\u00f3n: la CPU pierde tiempo traduciendo lo mismo una y otra vez.</li> </ul>"},{"location":"Lenguajes_de_programacion.html#modelo-h\u00edbrido-m\u00e1quinas-virtuales","title":"Modelo H\u00edbrido: M\u00e1quinas Virtuales","text":"<p>Muchos lenguajes actuales (Java, Python, C#) buscan un punto intermedio utilizando una estrategia de CPU Imaginaria.</p> <ol> <li> <p>Fase de Compilaci\u00f3n a Bytecode:     El c\u00f3digo fuente no se traduce a la ISA de la CPU real (Intel, ARM, etc.), sino que se genera un fichero intermedio conteniendo Bytecode (ej. <code>.class</code> en Java, <code>.pyc</code> en Python).     Este Bytecode no es m\u00e1s que la ISA (Instruction Set Architecture) de una m\u00e1quina ideal que no existe f\u00edsicamente. Es como traducir un libro de espa\u00f1ol a Esperanto en lugar de a 50 idiomas distintos.</p> </li> <li> <p>Fase de Ejecuci\u00f3n (La M\u00e1quina Virtual):     La M\u00e1quina Virtual (VM) no es hardware, sino un programa (software) instalado en el ordenador del usuario que act\u00faa como ese procesador ficticio.     De facto, la VM funciona como un int\u00e9rprete puro (pero sobre el bytecode, no sobre el c\u00f3digo fuente): lee las instrucciones del archivo intermedio y las traduce a la ISA nativa de la m\u00e1quina real (Ingl\u00e9s, Franc\u00e9s, Chino...) en tiempo real.     &gt; Como ocurre con cualquier int\u00e9rprete, si una instrucci\u00f3n de bytecode est\u00e1 dentro de un bucle, la VM la traducir\u00e1 una y otra vez en cada iteraci\u00f3n (salvo optimizaciones JIT), lo que implica una sobrecarga de rendimiento respecto al c\u00f3digo nativo.</p> </li> </ol> <p>Ventajas de la M\u00e1quina Virtual:</p> <ul> <li>Portabilidad (WORA): Write Once, Run Anywhere. El mismo bytecode corre en Windows, Linux o Mac, siempre que exista la VM correspondiente. N\u00f3tese que, aunque el bytecode es universal, el software de la VM s\u00ed es espec\u00edfico para cada plataforma (por eso debes descargar una versi\u00f3n distinta de Java o Python si usas Windows, Mac o Linux), ya que es la pieza que lidia con el hardware real.</li> <li>Seguridad: La VM act\u00faa como un entorno aislado (sandbox), protegiendo el hardware real.</li> <li>Gesti\u00f3n de Memoria (Limpieza autom\u00e1tica): En lenguajes de bajo nivel (como C), la gesti\u00f3n de la memoria din\u00e1mica es manual. Si un programador solicita espacio extra durante la ejecuci\u00f3n, es responsable de liberarlo expl\u00edcitamente. Un simple olvido en este paso provoca fallos graves (fugas de memoria). Para evitarlo, la VM incluye un Recolector de Basura (Garbage Collector): un \"servicio de limpieza\" autom\u00e1tico que detecta qu\u00e9 datos ya no sirven y los borra por ti.</li> </ul> <p>Compilaci\u00f3n JIT (Just-In-Time): Para mejorar el rendimiento, las VMs modernas (como la JVM de Java o V8 de JS) compilan trozos de bytecode a c\u00f3digo nativo mientras el programa se ejecuta, combinando la velocidad de un compilado con la flexibilidad de un interpretado.</p> <p>Ejemplos del Mundo Real:</p> <ul> <li>El Navegador Web: Es la m\u00e1quina virtual que m\u00e1s usamos. Chrome o Firefox interpretan el c\u00f3digo de las p\u00e1ginas web (JavaScript/WebAssembly) para que funcionen igual en tu PC, en un Mac o en tu m\u00f3vil.</li> <li>Java vs Android: Mientras que en ordenadores se usa la JVM est\u00e1ndar, Android utiliza su propia m\u00e1quina virtual llamada ART (Android Run Time). Aunque se programa en Java, el bytecode es diferente debido a temas de licencias y para optimizar el consumo de bater\u00eda en m\u00f3viles.</li> <li>.NET (C#): El entorno de Microsoft destaca por ser multilenguaje: compila alrededor de 35 lenguajes diferentes a un mismo bytecode llamado CIL (Common Intermediate Language). El lenguaje C# (C Sharp) es el m\u00e1s utilizado de este ecosistema y guarda muchas similitudes con Java y C++. Finalmente, un compilador JIT llamado CLR (Common Language Runtime) traduce y ejecuta ese c\u00f3digo en la plataforma hardware definitiva.</li> </ul> <p></p> La M\u00e1quina Virtual multilenguaje de Microsoft"},{"location":"Lenguajes_de_programacion.html#6-compiladores-frente-a-int\u00e9rpretes","title":"6. Compiladores frente a Int\u00e9rpretes","text":"<p>A continuaci\u00f3n, comparamos los enfoques principales: Compilaci\u00f3n Pura (C++), Interpretaci\u00f3n Pura (versiones antiguas de BASIC, Scripts de Shell) y Enfoque H\u00edbrido/VM (Java, Python).</p> Caracter\u00edstica Compilador Nativo (C++) Int\u00e9rprete Puro M\u00e1quina Virtual (Java/Python) Proceso Fuente \\(\\to\\) M\u00e1quina (Ejecutable) Fuente \\(\\to\\) Ejecuci\u00f3n directa Fuente \\(\\to\\) Bytecode \\(\\to\\) VM Cu\u00e1ndo se traduce Antes de ejecutar (tiempo de compilaci\u00f3n). Durante la ejecuci\u00f3n (tiempo real). Mixto (pre-compilaci\u00f3n a bytecode + JIT). Rendimiento Muy Alto. Optimizado para el hardware espec\u00edfico. Bajo. Sobrecarga por traducci\u00f3n constante. Medio/Alto. Gracias a tecnolog\u00edas JIT. Privacidad C\u00f3digo Alta (se entrega binario dif\u00edcil de leer). Nula (se entrega c\u00f3digo fuente visible). Media (se entrega bytecode, que es reversible). Portabilidad Baja. Requiere recompilar para cada SO. Alta. Solo requiere el int\u00e9rprete instalado. Muy Alta (WORA). Bytecode universal. Detecci\u00f3n Errores Todos los de sintaxis reportados antes de correr. El programa se detiene al encontrar el primer error. Errores de sintaxis al generar bytecode; l\u00f3gica en ejecuci\u00f3n. <p>Compiladores vs. Int\u00e9rpretes vs. M\u00e1quinas Virtuales</p> <p></p> <p></p> Compilaci\u00f3n vs M\u00e1quina Virtual"},{"location":"Lenguajes_de_programacion.html#7-ecosistema-de-desarrollo-ides","title":"7. Ecosistema de Desarrollo (IDEs)","text":"<p>Programar en un simple editor de texto (como el Bloc de Notas) es posible, pero ineficiente. Los profesionales usan IDEs (Integrated Development Environment), que combinan m\u00faltiples herramientas en una sola interfaz:</p> <ol> <li>Editor de c\u00f3digo: Con resaltado de sintaxis y autocompletado automatizado.</li> <li>Compilador/Int\u00e9rprete integrado: Para ejecutar el programa con un solo clic.</li> <li>Depurador (Debugger): Herramienta vital que permite detener la ejecuci\u00f3n paso a paso para inspeccionar variables y encontrar errores l\u00f3gicos.</li> <li>Gesti\u00f3n de proyectos: Organizaci\u00f3n de ficheros y control de versiones (Git).</li> </ol> <p>Ejemplos populares: Visual Studio Code (ligero y multiprop\u00f3sito), Eclipse/IntelliJ (Java), Visual Studio (C++/C#), PyCharm (Python), Spyder (Python)</p> <p>La forma en que programamos est\u00e1 en constante evoluci\u00f3n:</p> <ul> <li>Asistentes de IA: Herramientas como GitHub Copilot generan c\u00f3digo autom\u00e1ticamente a partir de descripciones en lenguaje natural, cambiando el rol del programador de escritor a supervisor.</li> <li>Low-Code / No-Code: Plataformas visuales para crear aplicaciones sin escribir c\u00f3digo manual, democratizando el desarrollo.</li> <li>Computaci\u00f3n Cu\u00e1ntica: Nuevos paradigmas y lenguajes (como Q# de Microsoft) dise\u00f1ados para operar con qubits (bits cu\u00e1nticos). Aunque su funcionamiento queda fuera del alcance de esta asignatura, esta tecnolog\u00eda promete resolver problemas hoy inabordables para la inform\u00e1tica cl\u00e1sica.</li> </ul>"},{"location":"Lenguajes_de_programacion.html#8-\u00e9tica-y-responsabilidad-en-la-era-de-la-ia","title":"8. \u00c9tica y Responsabilidad en la Era de la IA","text":"<p>El uso masivo de asistentes como ChatGPT o Copilot plantea importantes desaf\u00edos \u00e9ticos y acad\u00e9micos:</p> <ol> <li>Integridad Acad\u00e9mica (Cheating): En la universidad, presentar c\u00f3digo generado por IA como propio sin comprenderlo se considera plagio y anula el proceso de aprendizaje. Una calculadora resuelve operaciones, pero no te ense\u00f1a matem\u00e1ticas; la IA escribe c\u00f3digo, pero no te ense\u00f1a a razonar la l\u00f3gica (Vibecoding).</li> <li>Responsabilidad Profesional: Las IAs sufren alucinaciones (inventan c\u00f3digo plausible pero incorrecto). En ingenier\u00eda (sanidad, automoci\u00f3n...), un fallo de software puede costar vidas. El ingeniero humano siempre ser\u00e1 el responsable legal y moral de validar l\u00ednea por l\u00ednea lo que la m\u00e1quina escribe.</li> <li>Dependencia: Para supervisar eficazmente a una IA, primero hay que ser un experto. Si delegas el aprendizaje b\u00e1sico, nunca tendr\u00e1s criterio para corregir a tu asistente.</li> </ol>"},{"location":"Representacion_de_la_informacion.html","title":"Representaci\u00f3n de la Informaci\u00f3n","text":""},{"location":"Representacion_de_la_informacion.html#\u00edndice","title":"\u00cdndice","text":"<ol> <li>Fundamentos de la Informaci\u00f3n Digital</li> <li>Sistemas de Numeraci\u00f3n</li> <li>Representaci\u00f3n de N\u00fameros Enteros</li> <li>Representaci\u00f3n de N\u00fameros Reales</li> <li>Representaci\u00f3n de Caracteres</li> </ol>"},{"location":"Representacion_de_la_informacion.html#1-fundamentos-de-la-informaci\u00f3n-digital","title":"1. Fundamentos de la Informaci\u00f3n Digital","text":""},{"location":"Representacion_de_la_informacion.html#naturaleza-de-la-informaci\u00f3n-digital","title":"Naturaleza de la Informaci\u00f3n Digital","text":"<p>Desde una perspectiva t\u00e9cnica, la informaci\u00f3n se define como todo aquello capaz de reducir la incertidumbre o aportar conocimiento.</p> <p></p> Atributos y descriptores para la reducci\u00f3n de la incertidumbre <p></p> <p>En un sistema inform\u00e1tico, esta informaci\u00f3n se materializa en forma de datos procesables.</p> <p>En la arquitectura moderna de computadores (modelo Von Neumann), es fundamental comprender que la memoria principal almacena indistintamente dos categor\u00edas de entidades:</p> <ol> <li>Instrucciones (C\u00f3digo): La secuencia l\u00f3gica de \u00f3rdenes que dictan el comportamiento del procesador.</li> <li>Datos: La materia prima (n\u00fameros, caracteres, se\u00f1ales) sobre la que operan dichas instrucciones.</li> </ol> <p>A bajo nivel, no existe diferencia f\u00edsica entre instrucciones y datos; ambos se representan universalmente mediante patrones de bits (\\(0\\) y \\(1\\)), que en \u00faltima instancia corresponden a estados f\u00edsicos del hardware (niveles de voltaje, cargas el\u00e9ctricas, magnetizaci\u00f3n...). Es el contexto de ejecuci\u00f3n (c\u00f3mo y cu\u00e1ndo accede el procesador a ellos) lo que determina su interpretaci\u00f3n.</p> <p>Esta naturaleza binaria se mantiene porque es la soluci\u00f3n tecnol\u00f3gica m\u00e1s robusta: es m\u00e1s sencillo y seguro para un circuito distinguir entre dos estados extremos (On/Off) que intentar diferenciar 10 niveles de voltaje precisos, como requerir\u00eda una codificaci\u00f3n adaptada al sistema decimal.</p>"},{"location":"Representacion_de_la_informacion.html#almacenamiento-en-el-ordenador-la-memoria","title":"Almacenamiento en el Ordenador: La Memoria","text":"<p>La memoria principal del ordenador se estructura como una gran tabla lineal de celdas. Cada celda es un espacio de almacenamiento direccionable individualmente.</p> <p>En este esquema distinguimos dos conceptos clave:</p> <ol> <li>Direcci\u00f3n (Address): El n\u00famero \u00fanico que identifica la ubicaci\u00f3n de la celda (como el n\u00famero de un buz\u00f3n).</li> <li>Contenido: El patr\u00f3n de bits guardado en dicha celda.</li> </ol>"},{"location":"Representacion_de_la_informacion.html#unidades-de-medida","title":"Unidades de Medida","text":"<ul> <li>Bit (Binary digit): Unidad m\u00ednima de informaci\u00f3n (\\(0\\) o \\(1\\)).</li> <li>Byte (Octeto): Agrupaci\u00f3n de 8 bits. Es la unidad m\u00ednima direccionable de la memoria; el procesador lee o escribe bytes completos.</li> </ul>"},{"location":"Representacion_de_la_informacion.html#visualizaci\u00f3n-de-la-memoria","title":"Visualizaci\u00f3n de la Memoria","text":"<p>Podemos imaginar la memoria como una tabla donde cada fila representa una celda con su propia direcci\u00f3n. En las arquitecturas actuales lo habitual es el direccionamiento por Byte, donde cada direcci\u00f3n de memoria apunta a 8 bits.</p> <p>Dado que muchos datos requieren m\u00e1s capacidad, es com\u00fan que un solo dato ocupe varias celdas (direcciones) consecutivas:</p> Direcci\u00f3n Contenido (Binario) Interpretaci\u00f3n del Dato <code>...</code> <code>...</code> ... <code>1010</code> <code>01000001</code> Letra 'A' (1 Byte) <code>...</code> <code>...</code> ... <code>2000</code> <code>00000000</code> Entero de 32 bits (4 Bytes)Valor: 484 <code>2001</code> <code>00000000</code> <code>2002</code> <code>00000001</code> <code>2003</code> <code>11100100</code> <code>...</code> <code>...</code> ... <code>3008</code> <code>11100011</code> Instrucci\u00f3n CPU (64 bits)8 Bytes <code>...</code> <code>...</code> <code>3015</code> <code>10101100</code> <code>...</code> <code>...</code> ... <p>Modelo de la memoria como una tabla de celdas</p>"},{"location":"Representacion_de_la_informacion.html#necesidad-de-la-codificaci\u00f3n","title":"Necesidad de la Codificaci\u00f3n","text":"<p>Los humanos interactuamos con informaci\u00f3n simb\u00f3lica (letras, n\u00fameros) o anal\u00f3gica (im\u00e1genes, sonido), mientras que el procesador trabaja internamente con estados binarios. Para salvar esta brecha es necesaria una transformaci\u00f3n rigurosa:</p> \\[ \\text{Mundo Real} \\xrightarrow{\\text{Codificaci\u00f3n}} \\text{Mundo Digital} \\] <p>En la vida real usamos habitualmente codificaciones: el NIA de un alumno de la UVa, el DNI, el c\u00f3digo postal, etc.</p> <p>Matem\u00e1ticamente, la codificaci\u00f3n debe ser una transformaci\u00f3n inyectiva. En el caso inform\u00e1tico esto significa que a cada elemento del conjunto original (ej. la letra 'A') le debe corresponder una secuencia de bits \u00fanica y exclusiva. Si dos elementos distintos compartieran el mismo c\u00f3digo, el proceso inverso (decodificaci\u00f3n) ser\u00eda ambiguo y no podr\u00edamos recuperar la informaci\u00f3n original sin errores.</p>"},{"location":"Representacion_de_la_informacion.html#capacidad-de-representaci\u00f3n-combinatoria","title":"Capacidad de Representaci\u00f3n (Combinatoria)","text":"<p>Es un error com\u00fan pensar que los bits suman capacidad linealmente. En realidad, la capacidad de diferenciar valores crece de forma exponencial: cada bit a\u00f1adido duplica las posibilidades del anterior.</p> <p>Regla General: Con \\(n\\) bits podemos representar \\(m = 2^n\\) valores diferentes.</p> N\u00ba Bits C\u00e1lculo (\\(2^n\\)) Cantidad de Valores Ejemplo de uso 1 \\(2^1\\) 2 Bombilla (Encendida/Apagada) 2 \\(2^2\\) 4 Los 4 palos de la baraja 3 \\(2^3\\) 8 Rosa de los Vientos (N, S, E, O ,NO, NE, SO, etc.) ... ... ... ... 8 \\(2^8\\) 256 1 Byte (Podemos representar caracteres) 10 \\(2^{10}\\) 1.024 Aprox. 1000 (\\(1K\\) en Binario) 32 \\(2^{32}\\) ~4.000 Millones Direcciones IP (Internet) <p>N\u00famero de bits frente a capacidad de representaci\u00f3n</p> <p>Problema inverso: Si necesito codificar \\(m\\) valores, \u00bfcu\u00e1l es el n\u00famero m\u00ednimo \\(n\\) de bits necesarios?</p> \\[ n = \\lceil \\log_2 m \\rceil \\quad \\longrightarrow \\quad \\text{Tomamos el entero m\u00e1s pr\u00f3ximo por exceso} \\] <p>Ejemplo de c\u00e1lculo de bits necesarios</p> <p>Tenemos un almac\u00e9n con 17524 contenedores y queremos identificarlos con una etiqueta binaria \u00fanica.</p> \\[ \\log_2 17524 \\approx 14.097 \\] <p>Soluci\u00f3n: Necesitamos 15 bits (con 14 bits solo llegar\u00edamos a 16.384 etiquetas).</p>"},{"location":"Representacion_de_la_informacion.html#2-sistemas-de-numeraci\u00f3n","title":"2. Sistemas de Numeraci\u00f3n","text":"<p>Antes de abordar c\u00f3mo se almacenan en un sistema inform\u00e1tico tipos de datos espec\u00edficos (enteros, reales, texto), es imprescindible revisar la base matem\u00e1tica que lo sustenta. Aunque en la vida cotidiana operamos en base 10, el hardware impone el uso de bases potencias de 2.</p> <p>El objetivo de este apartado no es convertirse en calculadoras humanas, sino entender la l\u00f3gica de traducci\u00f3n entre el mundo humano y el de la m\u00e1quina. Este conocimiento es vital para interpretar direcciones de memoria, entender los l\u00edmites de capacidad de las variables o comprender c\u00f3mo se representa internamente cualquier tipo de dato.</p>"},{"location":"Representacion_de_la_informacion.html#definici\u00f3n","title":"Definici\u00f3n","text":"<p>Un sistema de numeraci\u00f3n es una colecci\u00f3n de s\u00edmbolos y reglas para construir n\u00fameros v\u00e1lidos. Los sistemas usados en inform\u00e1tica son posicionales: el valor de una cifra depende de su s\u00edmbolo y de la posici\u00f3n que ocupa.</p> <p>La base (\\(b\\)) es el n\u00famero total de s\u00edmbolos permitidos en el sistema. En un sistema posicional, la base tambi\u00e9n determina cu\u00e1ntas unidades de un orden inferior son necesarias para formar una unidad del orden inmediato superior (ej. 10 unidades forman 1 decena). Adem\u00e1s, la base coincide con el valor por el cual se multiplican las posiciones sucesivas.</p> Sistema Base (\\(b\\)) S\u00edmbolos Decimal 10 \\(\\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\}\\) Binario 2 \\(\\{0, 1\\}\\) Octal 8 (\\(2^3\\)) \\(\\{0, 1, 2, 3, 4, 5, 6, 7\\}\\) Hexadecimal 16 (\\(2^4\\)) \\(\\{0, ..., 9, A, B, C, D, E, F\\}\\) <p>Bases habituales en Inform\u00e1tica: A=10, B=11, ..., F=15</p>"},{"location":"Representacion_de_la_informacion.html#valor-posicional-polinomio-equivalente","title":"Valor Posicional (Polinomio Equivalente)","text":"<p>El concepto fundamental de los sistemas num\u00e9ricos modernos es el valor posicional. A diferencia de los n\u00fameros romanos, aqu\u00ed el valor de cada d\u00edgito no es absoluto, sino que depende de la posici\u00f3n que ocupe respecto a la coma (o punto) decimal.</p> <p>Cada posici\u00f3n \\(i\\) tiene un peso asignado que es una potencia de la base (\\(b^i\\)):</p> <ul> <li>Hacia la izquierda (parte entera), los pesos son potencias no negativas: \\(b^0\\) (unidades), \\(b^1\\), \\(b^2\\)...</li> <li>Hacia la derecha (parte fraccionaria), los pesos son potencias negativas: \\(b^{-1}\\), \\(b^{-2}\\)...</li> </ul> <p>Para traducir cualquier n\u00famero a nuestro sistema decimal, simplemente sumamos cada d\u00edgito multiplicado por su peso. Esto se formaliza mediante el polinomio equivalente:</p> \\[ N = \\sum_{i=-k}^{n-1} d_i \\cdot b^i \\] \\[ N = d_{n-1}b^{n-1} + \\dots + d_1 b^1 + d_0 b^0 + d_{-1} b^{-1} + \\dots + d_{-k} b^{-k} \\] <p>donde:</p> <ul> <li>\\(d_i\\): Es el d\u00edgito en la posici\u00f3n \\(i\\).</li> <li>\\(b\\): Es la base del sistema (2, 8, 16...).</li> <li>\\(i\\): Es el \u00edndice de la posici\u00f3n (\\(i=0\\) es la primera posici\u00f3n entera).</li> </ul> <p>Ejemplo: Hexadecimal a Decimal</p> <p>Valor del n\u00famero \\(3F.D_{16}\\):</p> \\[ 3 \\cdot 16^1 + 15 \\cdot 16^0 + 13 \\cdot 16^{-1} = 48 + 15 + 0.8125 = 63.8125_{10} \\] <p>(Nota: F=15, D=13)</p>"},{"location":"Representacion_de_la_informacion.html#conversi\u00f3n-de-decimal-a-base-b","title":"Conversi\u00f3n de Decimal a Base \\(b\\)","text":"<p>Para convertir un n\u00famero de nuestro sistema decimal a cualquier otra base (binario, octal, hexadecimal...), debemos procesar por separado la parte entera y la fraccionaria, ya que responden a l\u00f3gicas matem\u00e1ticas inversas.</p> <p>El m\u00e9todo general consiste en dividir la parte entera y multiplicar la parte fraccionaria.</p>"},{"location":"Representacion_de_la_informacion.html#1-parte-entera-divisiones-sucesivas","title":"1. Parte Entera: Divisiones Sucesivas","text":"<p>El algoritmo consiste en dividir sucesivamente el n\u00famero decimal entre la base destino (\\(b\\)) hasta que el cociente sea 0.</p> <ul> <li>En cada paso, el resto de la divisi\u00f3n se convierte en un d\u00edgito del n\u00famero convertido.</li> <li>Importante: El primer resto obtenido corresponde al bit menos significativo (LSD o posici\u00f3n \\(b^0\\)). Por tanto, el n\u00famero final se construye leyendo los restos en orden inverso (del \u00faltimo obtenido al primero).</li> </ul>"},{"location":"Representacion_de_la_informacion.html#2-parte-fraccionaria-multiplicaciones-sucesivas","title":"2. Parte Fraccionaria: Multiplicaciones Sucesivas","text":"<p>Tomamos la parte decimal pura (0.xxxx) y la multiplicamos por la base destino (\\(b\\)).</p> <ul> <li>La parte entera del resultado ser\u00e1 el siguiente d\u00edgito fraccionario (empezando por \\(b^{-1}\\)).</li> <li>El proceso se repite tomando solo la parte decimal restante del resultado anterior.</li> <li>En este caso, los d\u00edgitos se leen en orden directo (en el orden en que aparecen).</li> </ul> <p>Ejemplo Completo: 35.625 a Binario</p> <p>Paso 1: Parte Entera (35)</p> <ul> <li>\\(35 / 2 = 17\\), Resto 1 (Este es el \u00faltimo bit, LSB)</li> <li>\\(17 / 2 = 8\\), Resto 1</li> <li>\\(8 / 2 = 4\\), Resto 0</li> <li>\\(4 / 2 = 2\\), Resto 0</li> <li>\\(2 / 2 = 1\\), Resto 0</li> <li>\\(1 / 2 = 0\\), Resto 1 (Este es el primer bit, MSB)</li> </ul> <p>\\(\\rightarrow\\) Leemos de abajo hacia arriba: \\(100011_2\\)</p> <p>Paso 2: Parte Fraccionaria (0.625)</p> <ul> <li>\\(0.625 \\times 2 = \\mathbf{1}.25 \\rightarrow\\) Guardo el 1, me quedo con \\(0.25\\)</li> <li>\\(0.25 \\times 2 = \\mathbf{0}.5 \\rightarrow\\) Guardo el 0, me quedo con \\(0.5\\)</li> <li>\\(0.5 \\times 2 = \\mathbf{1}.0 \\rightarrow\\) Guardo el 1, me queda \\(0.0\\) (Fin)</li> </ul> <p>\\(\\rightarrow\\) Leemos de arriba hacia abajo: \\(.101_2\\)</p> <p>Resultado Final: \\(35.625_{10} = 100011.101_2\\)</p>"},{"location":"Representacion_de_la_informacion.html#error-de-truncamiento-y-precisi\u00f3n-finita","title":"Error de Truncamiento y Precisi\u00f3n Finita","text":"<p>En la parte fraccionaria, la conversi\u00f3n a menudo no es exacta, resultando en n\u00fameros peri\u00f3dicos infinitos (al igual que \\(1/3\\) es \\(0.333...\\) en decimal).</p> <p>Ejemplo con error de truncamiento</p> <p>Por ejemplo, el simple valor \\(0.1_{10}\\) en binario es una fracci\u00f3n peri\u00f3dica: \\(0.0001100110011...\\)</p> <p>Dado que el ordenador tiene un n\u00famero finito de bits para guardar el n\u00famero, est\u00e1 obligado a cortar (truncar) la secuencia en alg\u00fan punto.</p> <p>C\u00e1lculo del error con 4 bits fraccionarios: Si solo guardamos los primeros 4 bits fraccionarios, almacenamos \\(0.0001_2\\).</p> <ul> <li>Valor Real: \\(0.1\\)</li> <li>Valor Almacenado: \\(0.0001_2 = 1 \\cdot 2^{-4} = 0.0625_{10}\\)</li> <li>Error: \\(|0.1 - 0.0625| = 0.0375\\) (\u00a1Un error del 37.5%!)</li> </ul> <p>Esto implica que el ordenador casi nunca guarda exactamente el n\u00famero real que escribimos, sino una aproximaci\u00f3n muy cercana. El aumento del n\u00famero de bits dedicado a almacenar la parte fraccionaria de un n\u00famero pal\u00eda el error, pero nunca desaparece en fracciones peri\u00f3dicas o valores irracionales.</p>"},{"location":"Representacion_de_la_informacion.html#uso-de-hexadecimal-y-octal","title":"Uso de Hexadecimal y Octal","text":"<p>Aunque el ordenador trabaja estrictamente en binario, para los humanos leer secuencias largas como <code>101101011110</code> es lento, tedioso y muy propenso a errores visuales. </p> <p>Por esta raz\u00f3n, en inform\u00e1tica se utilizan sistemas cuya base es una potencia exacta de 2 (\\(8=2^3\\) y \\(16=2^4\\)). Estos sistemas funcionan como una taquigraf\u00eda del binario, permiti\u00e9ndonos escribir la misma informaci\u00f3n de forma mucho m\u00e1s compacta sin tener que hacer divisiones o multiplicaciones complejas para la traducci\u00f3n.</p> <ul> <li>Hexadecimal (Base 16): Es el est\u00e1ndar absoluto hoy en d\u00eda. Se utiliza universalmente para representar direcciones de memoria, c\u00f3digos de colores web (#FFFFFF), direcciones MAC o cualquier volcado de datos crudos (raw data). Un solo d\u00edgito hexadecimal representa 4 bits (un nibble), por lo que dos d\u00edgitos hexadecimales representan exactamente 1 Byte.</li> <li>Octal (Base 8): Agrupa los bits de 3 en 3. Fue muy popular en las primeras d\u00e9cadas de la inform\u00e1tica (para palabras de 12, 24 o 36 bits), pero hoy su uso ha quedado relegado casi exclusivamente a la gesti\u00f3n de permisos de ficheros en sistemas UNIX/Linux (ej. <code>chmod 755</code>).</li> </ul>"},{"location":"Representacion_de_la_informacion.html#m\u00e9todo-de-conversi\u00f3n-por-agrupaci\u00f3n","title":"M\u00e9todo de Conversi\u00f3n por Agrupaci\u00f3n","text":"<p>La conversi\u00f3n es directa y visual, ya que cada d\u00edgito en estas bases corresponde a un bloque fijo de bits.</p> <ol> <li>Binario \\(\\to\\) Hexadecimal: Agrupamos los bits de 4 en 4 partiendo desde la coma decimal hacia los extremos (izquierda para enteros, derecha para fracci\u00f3n). Si el \u00faltimo grupo queda incompleto, se rellena con ceros.</li> <li>Binario \\(\\to\\) Octal: El mismo proceso, pero haciendo grupos de 3 bits.</li> </ol> <p>Ejemplo Completo con Decimales y Relleno</p> <p>Convertir a Hexadecimal el binario: <code>111010.11011</code></p> <p>El proceso exige agrupar de 4 en 4 desde la coma hacia afuera.</p> <p>1. Parte Entera (<code>111010</code>): *   Desde la coma a la izquierda: <code>1010</code> (grupo completo) \\(\\to\\) Quedan <code>11</code> sueltos. *   Rellenamos con ceros a la izquierda: <code>0011</code>. *   Grupos resultantes: <code>0011</code> | <code>1010</code> \\(\\to\\) 3 | A</p> <p>2. Parte Fraccionaria (<code>.11011</code>): *   Desde la coma a la derecha: <code>1101</code> (grupo completo) \\(\\to\\) Queda <code>1</code> suelto. *   Rellenamos con ceros a la derecha: <code>1000</code>. *   Grupos resultantes: <code>1101</code> | <code>1000</code> \\(\\to\\) D | 8</p> <p>Resultado: \\(3A.D8_{16}\\)</p> <p>(Nota: Los ceros de relleno son cruciales. Si en la parte fraccionaria hubi\u00e9ramos tomado <code>1</code> como <code>0001</code> (1) en vez de <code>1000</code> (8), el error ser\u00eda enorme)</p> <p>Convertir directamente de Octal a Hexadecimal o viceversa es simple si se usa como estrategia el Binario como puente:</p> \\[ \\text{Octal} \\xrightarrow{\\text{expandir a 3 bits}} \\text{Binario} \\xrightarrow{\\text{agrupar de 4 bits}} \\text{Hexadecimal} \\] \\[ \\text{Hexadecimal} \\xrightarrow{\\text{expandir a 4 bits}} \\text{Binario} \\xrightarrow{\\text{agrupar de 3 bits}} \\text{Octal} \\]"},{"location":"Representacion_de_la_informacion.html#3-representaci\u00f3n-de-n\u00fameros-enteros","title":"3. Representaci\u00f3n de N\u00fameros Enteros","text":"<p>Los n\u00fameros enteros son la piedra angular de la aritm\u00e9tica computacional. No solo representan cantidades matem\u00e1ticas, sino que constituyen el lenguaje interno del procesador: las direcciones de memoria, los punteros, los \u00edndices de arrays y los contadores de bucles son, estructuralmente, n\u00fameros enteros.</p> <p>A diferencia de los n\u00fameros reales, la aritm\u00e9tica entera es exacta; no sufre de errores de precisi\u00f3n por redondeo. Sin embargo, se enfrenta a una limitaci\u00f3n f\u00edsica ineludible: el rango finito. Al tener un n\u00famero fijo de bits (ancho de palabra), existe un l\u00edmite m\u00e1ximo y m\u00ednimo estricto que podemos representar, y superar ese l\u00edmite tiene consecuencias dr\u00e1sticas.</p>"},{"location":"Representacion_de_la_informacion.html#enteros-sin-signo-binario-puro","title":"Enteros Sin Signo (Binario Puro)","text":"<p>Este formato se emplea para modelar problemas reales donde las magnitudes son siempre no negativas (el conjunto de los Naturales \\(\\mathbb{N}\\) m\u00e1s el cero).</p> <p>Usos t\u00edpicos:</p> <ul> <li>Contadores de elementos (ej. n\u00famero de alumnos).</li> <li>\u00cdndices para acceder a listas o vectores.</li> <li>Direcciones de memoria.</li> </ul> <p>La representaci\u00f3n interna coincide exactamente con el sistema num\u00e9rico posicional base 2 visto anteriormente. Al no necesitar guardar informaci\u00f3n sobre el signo, utilizamos los \\(n\\) bits completos para la magnitud.</p> <ul> <li>Rango Representable: \\([0, \\quad 2^n - 1]\\)</li> </ul> Decimal Patr\u00f3n Binario (\\(b_7 \\dots b_0\\)) L\u00f3gica 0 <code>00000000</code> Todos apagados 1 <code>00000001</code> \\(2^0\\) 2 <code>00000010</code> \\(2^1\\) 3 <code>00000011</code> \\(2^1 + 2^0\\) ... ... ... 254 <code>11111110</code> \\(2^7 + 2^6 + ... + 2^0\\) 255 <code>11111111</code> M\u00e1ximo (\\(2^8 - 1\\)) <p>Tabla de Valores para \\(n=8\\) bits</p>"},{"location":"Representacion_de_la_informacion.html#desbordamiento","title":"Desbordamiento","text":"<p>Si a 255 (<code>11111111</code>) le sumamos 1, el resultado matem\u00e1tico ser\u00eda 256 (<code>100000000</code>), pero como solo tenemos 8 bits, el bit superior se pierde y el resultado almacenado vuelve a ser 0 (<code>00000000</code>). Esto es el desbordamiento (overflow).</p>"},{"location":"Representacion_de_la_informacion.html#enteros-con-signo","title":"Enteros Con Signo","text":""},{"location":"Representacion_de_la_informacion.html#1-signo-y-magnitud","title":"1. Signo y Magnitud","text":"<p>Es la forma m\u00e1s intuitiva para los humanos de representar n\u00fameros negativos. Consiste en utilizar el bit m\u00e1s significativo (MSB) exclusivamente para codificar el signo:</p> <ul> <li>Bit de Signo: <code>0</code> para positivos, <code>1</code> para negativos.</li> <li>Magnitud: Los \\(n-1\\) bits restantes codifican el valor absoluto del n\u00famero en binario puro.</li> </ul> <p>Rango de Representaci\u00f3n: \\([-(2^{n-1} - 1), \\quad +(2^{n-1} - 1)]\\)</p> <p>Representar en Signo y Magnitud -47 con 8 bits</p> <p>Queremos codificar el n\u00famero decimal \\(-47_{10}\\).</p> <ol> <li>Bit de Signo: Como es negativo, el bit m\u00e1s a la izquierda (MSB) es <code>1</code>.</li> <li>Magnitud (7 bits restantes):<ul> <li>Calculamos el valor absoluto: \\(|-47| = 47\\).</li> <li>Descomponemos en potencias de 2: \\(47 = 32 + 8 + 4 + 2 + 1\\).</li> <li>En binario puro es <code>101111</code> (6 bits).</li> <li>Rellenamos con ceros a la izquierda hasta completar los 7 bits reservados para la magnitud: <code>0101111</code>.</li> </ul> </li> </ol> <p>Resultado Final: <code>1</code> (Signo) + <code>0101111</code> (Magnitud) = <code>10101111</code></p> <p>Problemas y Desuso: Aunque conceptualmente sencilla, esta representaci\u00f3n tiene graves defectos para el dise\u00f1o de hardware:</p> <ol> <li>Doble Cero: Existen el \\(+0\\) (<code>00000000</code>) y el \\(-0\\) (<code>10000000</code>). Esto complica las comparaciones (<code>if x == 0</code>).</li> <li>Aritm\u00e9tica Compleja: La CPU necesitar\u00eda evaluar los signos antes de operar (como hacemos los humanos: \"si los signos son distintos, restamos\"). Esto es ineficiente; se prefiere un sistema donde la electr\u00f3nica asociada a la suma funcione igual para positivos y negativos.</li> </ol>"},{"location":"Representacion_de_la_informacion.html#2-complemento-a-2-c2","title":"2. Complemento a 2 (C2)","text":"<p>Es el sistema est\u00e1ndar utilizado por la aritm\u00e9tica de enteros en casi todos los procesadores modernos y el formato detr\u00e1s del tipo entero en muchos de los lenguajes de programaci\u00f3n.</p> <p>Definici\u00f3n Matem\u00e1tica: El complemento a la base \\(b\\) de un n\u00famero positivo \\(X\\) codificado con \\(n\\) cifras se define como \\(b^n - X\\). En binario (\\(b=2\\)), esto es lo que llamamos Complemento a 2.</p> <p>Reglas de Representaci\u00f3n:</p> <ul> <li>Positivos y el 0: Se representan id\u00e9ntico a Signo-Magnitud (el MSB es <code>0</code>).</li> <li>Negativos: Se representan calculando el complemento a 2 de su valor absoluto (el MSB es <code>1</code>).</li> </ul> <p>Interpretaci\u00f3n del Peso Negativo (Polinomio Equivalente): Lo m\u00e1s interesante del C2 es que el bit de signo (MSB, posici\u00f3n \\(n-1\\)) no es solo una etiqueta, sino que tiene valor matem\u00e1tico. Su peso es igual a la potencia correspondiente pero con signo negativo.</p> \\[ N = -d_{n-1} \\cdot 2^{n-1} + \\sum_{i=0}^{n-2} d_i \\cdot 2^i \\] \\[ N = \\mathbf{-d_{n-1}2^{n-1}} + d_{n-2}2^{n-2} + \\dots + d_1 2^1 + d_0 2^0 \\] <ul> <li>Rango: \\([-2^{n-1}, \\quad 2^{n-1} - 1]\\). (Es asim\u00e9trico: hay un valor negativo extra porque el 0 \"gasta\" una combinaci\u00f3n de los positivos).</li> </ul> <p>Ejemplo: Obtener el n\u00famero negativo \\(-13\\) en C2 con 6 bits</p> <p>Escribir el positivo: \\(13_{10} = 001101_2\\) (Rellenamos con ceros hasta 6 bits)</p> <p>M\u00e9todo 1: Inversi\u00f3n + 1 (Est\u00e1ndar)</p> <ul> <li>Invertir todos los bits (cambiar 0s por 1s): <code>110010</code></li> <li>Sumar 1 al resultado final: <code>110010</code> + <code>1</code> = <code>110011</code></li> </ul> <p>M\u00e9todo 2: Regla r\u00e1pida (Visual)</p> <ul> <li>Recorrer de derecha a izquierda hasta el primer '1' (inclusive), dejar esos bits igual e invertir el resto.</li> <li><code>00110</code><code>1</code> \\(\\to\\) Invertir parte izquierda \\(\\to\\) <code>11001</code><code>1</code></li> </ul> <p>M\u00e9todo 3: Definici\u00f3n Matem\u00e1tica (\\(2^n - X\\))</p> <ul> <li>Aplicamos la f\u00f3rmula estricta con \\(n=6\\) y \\(X=13\\).</li> <li>\\(2^6 - 13 = 64 - 13 = 51\\)</li> <li>Convertimos 51 a binario puro \\(\\to\\) <code>110011</code></li> </ul> <p>Ejemplo: Obtener el n\u00famero negativo \\(-13\\) en C2 con 10 bits</p> <p>Escribir el positivo: \\(13_{10} = 0000001101_2\\) (Rellenamos con ceros hasta 10 bits)</p> <p>M\u00e9todo 1: Inversi\u00f3n + 1 (Est\u00e1ndar)</p> <ul> <li>Invertir todos los bits: <code>1111110010</code></li> <li>Sumar 1: <code>1111110010</code> + <code>1</code> = <code>1111110011</code></li> </ul> <p>M\u00e9todo 2: Regla r\u00e1pida (Visual)</p> <ul> <li><code>000000110</code><code>1</code> \\(\\to\\) Invertir parte izquierda \\(\\to\\) <code>111111001</code><code>1</code></li> </ul> <p>M\u00e9todo 3: Definici\u00f3n Matem\u00e1tica</p> <ul> <li>\\(2^{10} - 13 = 1024 - 13 = 1011\\)</li> <li>\\(1011_{10}\\) en binario es <code>1111110011</code></li> </ul> <p>Resultado: \\(1111110011_{C2}\\)</p> <p>Curiosidad Hist\u00f3rica: El Complemento a 1</p> <p>Existe otra representaci\u00f3n llamada Complemento a la base menos 1 (Complemento a 1 en binario), que se obtiene simplemente intercambiando 0s y 1s.</p> <p>Esta t\u00e9cnica fue utilizada en algunas series de computadoras pioneras descendientes de la ENIAC, como la serie UNIVAC. Actualmente est\u00e1 en desuso frente al Complemento a 2 porque, al igual que el Signo-Magnitud, sufre del problema del doble cero.</p> <p>La Analog\u00eda del Reloj</p> <p>El Complemento a 2 funciona exactamente igual que los minutos en un reloj anal\u00f3gico (aritm\u00e9tica modular).</p> <p>Si el reloj marca las <code>:00</code> y queremos restar 10 minutos:</p> <ul> <li>Opci\u00f3n A (Resta): Mover la aguja 10 minutos hacia atr\u00e1s \\(\\to\\) Posici\u00f3n <code>:50</code>.</li> <li>Opci\u00f3n B (Suma del Complemento): Mover la aguja 50 minutos hacia adelante \\(\\to\\) Posici\u00f3n <code>:50</code>.</li> </ul> <p>En un sistema c\u00edclico (limitado), avanzar 50 pasos te deja en el mismo sitio que retroceder 10.</p> <p>El ordenador usa este truco para no tener que implementar la resta en hardware (que es costosa). Por ejemplo, en un sistema de 8 bits (donde la vuelta completa son 256 pasos), restar 1 es equivalente a sumar 255.</p> <p>Si calculamos \\(5 + 255\\), la suma aritm\u00e9tica es \\(260\\). Pero como solo tenemos 8 bits, se produce un desbordamiento (se pierde el bit que sobra al dar la vuelta) y el contador se queda en \\(4\\). $$ 5 + 255 \\equiv 4 \\pmod{256} $$ \u00a1Hemos conseguido el resultado correcto (\\(5-1=4\\)) usando solo la suma!</p>"},{"location":"Representacion_de_la_informacion.html#la-suma-binaria","title":"La suma Binaria","text":"<p>Aunque las CPUs modernas son capaces de realizar operaciones aritm\u00e9ticas complejas (multiplicaci\u00f3n, divisi\u00f3n...), la base fundamental del dise\u00f1o hardware es la suma. De hecho, operaciones como la multiplicaci\u00f3n se implementan a menudo mediante secuencias r\u00e1pidas de sumas y desplazamientos (shifts). Por este motivo, nos centraremos en analizar en detalle el circuito sumador como bloque constructivo esencial de la ALU.</p> <p>La genialidad del uso del Complemento a 2 radica en que elimina la distinci\u00f3n entre suma y resta. Matem\u00e1ticamente y el\u00e9ctricamente, restar es simplemente sumar un n\u00famero negativo: $$ A - B \\iff A + (-B) $$ Esta propiedad permite que un \u00fanico circuito f\u00edsico resuelva ambas operaciones, simplificando dr\u00e1sticamente el dise\u00f1o del procesador.</p>"},{"location":"Representacion_de_la_informacion.html#reglas-b\u00e1sicas","title":"Reglas b\u00e1sicas","text":"<p>Las reglas b\u00e1sicas para sumar 2 bits son:</p> <ul> <li>\\(0+0=0\\)</li> <li>\\(0+1=1\\) </li> <li>\\(1+0=1\\) </li> <li>\\(1+1=10\\)</li> </ul> <p>Al igual que ocurre en la aritm\u00e9tica decimal (ej. \\(7+8=15\\)), se produce acarreo en el caso \\(1+1=10\\). La suma aislada de dos bits, conocida como semisumador binario, podemos describirla con una tabla de verdad con dos bits de entrada, \\(p\\) y \\(q\\), y dos bits de salida, suma \\(S\\) y acarreo \\(C\\).</p> \\(p\\) \\(q\\) \\(C\\) (Acarreo) \\(S\\) (Suma) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 <p>Tabla de Verdad del semisumador binario</p> <p></p> Semisumador binario <p></p> <p>El problema del semisumador es que no puede gestionar el acarreo procedente de una suma anterior. Si queremos sumar n\u00fameros de varios bits (como hacemos en papel), necesitamos un circuito que sume tres cosas: el bit del primer n\u00famero, el bit del segundo, y el acarreo de entrada (\\(C_{e}\\)) que arrastramos de la posici\u00f3n previa.</p> <p>Propagaci\u00f3n del acarreo</p> <p>Supongamos que queremos sumar \\(6_{10} + 7_{10}\\) en binario (\\(00110 + 00111\\)). Al igual que ocurre en la aritm\u00e9tica decimal (ej. \\(87+78\\)), se generan acarreos que deben sumarse en la siguiente posici\u00f3n:</p> <pre><code>    1 1        &lt;-- Acarreos\n  0 0 1 1 0      (6)\n+ 0 0 1 1 1      (7)\n-----------\n  0 1 1 0 1      (13)\n</code></pre> <p>Por esta raz\u00f3n necesitamos el Sumador Completo, que es capaz de procesar ese tercer bit de entrada.</p> <p>El sumador completo binario podemos describirlo con una tabla de verdad con tres bits de entrada, \\(p\\), \\(q\\) y \\(C_e\\) y dos bits de salida \\(S\\) y \\(C_s\\). \\(C_e\\) es el valor de acarreo procedente de la suma de los bits anteriores y \\(C_s\\) es el acarreo que se inyecta a la siguiente suma de bits.</p> \\(p\\) \\(q\\) \\(C_e\\) (Entrada) \\(C_s\\) (Salida) \\(S\\) (Suma) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 <p>Tabla de Verdad del sumador binario completo</p> <p></p> <p></p> Sumador completo binario <p></p> <p>Supongamos que necesitamos sumar dos n\u00fameros binarios \\(x_3x_2x_1x_0\\) e \\(y_3y_2y_1y_0\\) de 4 bits. Bastar\u00eda disponer de 4 sumadores completos colocados en serie para realizar la operaci\u00f3n en paralelo.</p> <p></p> Sumadores en serie <p></p> <p>Combinando sumadores completos podemos sumar n\u00fameros con el n\u00famero de bits deseado. </p>"},{"location":"Representacion_de_la_informacion.html#justificaci\u00f3n-del-uso-de-c2-en-la-cpu","title":"Justificaci\u00f3n del uso de C2 en la CPU","text":"<p>Veamos la raz\u00f3n fundamental por la que los ordenadores utilizan Complemento a 2 analizando la operaci\u00f3n \\(6 + (-7)\\) (cuyo resultado debe ser \\(-1\\)) con un sumador binario est\u00e1ndar de 4 bits.</p> <p>1. Usando Signo-Magnitud: En Signo-Magnitud, el bit m\u00e1s significativo es el signo. * \\(6_{10} \\rightarrow 0110_{SM}\\) * \\(-7_{10} \\rightarrow 1111_{SM}\\)</p> <p>Si sumamos estos patrones de bits directamente:</p> <pre><code>   1 1 1          &lt;-- Acarreos\n     0 1 1 0      (6)\n  +  1 1 1 1      (-7)\n  ----------\n   1 0 1 0 1      (+5) --&gt; \u00a1ERROR! \u00a1El \u00faltimo bit de acarreo se pierde!\n</code></pre> <p>El resultado obtenido \\(0101_{SM}\\) corresponde a \\(+5_{10}\\). \u00a1El resultado es ERR\u00d3NEO! Un sumador est\u00e1ndar no funciona para n\u00fameros mixtos en Signo-Magnitud.</p> <p>2. Usando Complemento a 2 (C2): * \\(6_{10} \\rightarrow 0110_{C2}\\) * \\(-7_{10} \\rightarrow 1001_{C2}\\) ( Invertir \\(0111 \\rightarrow 1000\\); Sumar \\(1 \\rightarrow 1001\\))</p> <p>Operando con el mismo circuito sumador:</p> <pre><code>                 &lt;-- Acarreos\n    0 1 1 0      (6)\n  + 1 0 0 1      (-7)\n  ---------\n    1 1 1 1      (-1) --&gt; \u00a1CORRECTO!\n</code></pre> <p>El resultado \\(1111_{C2}\\) corresponde al valor \\(-1_{10}\\) (pues \\(-8 + 4 + 2 + 1 = -1\\)). \u00a1El resultado es CORRECTO!</p> <p>Eficiencia del C2</p> <p>Esta propiedad es la justificaci\u00f3n real del uso universal del Complemento a 2 en las CPUs modernas: permite utilizar el mismo circuito sumador para operaciones con y sin signo, simplificando enormemente el dise\u00f1o del hardware (ALU).</p> <p>Desbordamiento (Overflow) vs Acarreo</p> <p>Es crucial diferenciar entre el acarreo (carry out), que es normal y se ignora en aritm\u00e9tica con signo, y el desbordamiento (overflow), que es un error cr\u00edtico.</p> <p>Regla de Detecci\u00f3n: El desbordamiento ocurre cuando se suman dos n\u00fameros del mismo signo y el resultado tiene el signo opuesto. Nunca ocurre si los signos son distintos.</p> <p>Imaginemos un sistema de 4 bits (Rango: \\([-8, +7]\\)).</p> <p>1. Acarreo NO Problem\u00e1tico (Se ignora): Sumamos \\((-3) + (-2) = -5\\). (Dentro de rango).</p> <p><pre><code>  1 1       &lt;-- Acarreos\n    1 1 0 1  (-3)\n  + 1 1 1 0  (-2)\n  ---------\n  1 1 0 1 1  --&gt; Nos quedamos con 4 bits: 1011 (-5) \u00a1CORRECTO!\n</code></pre> El bit sobrante (5\u00ba bit) se descarta y el resultado es matem\u00e1ticamente correcto.</p> <p>2. Desbordamiento Problem\u00e1tico (Error): Sumamos \\(5 + 4 = 9\\). (Fuera de rango, m\u00e1ximo es 7).</p> <p><pre><code>    1        &lt;-- Acarreo entra en bit signo pero NO sale\n    0 1 0 1  (5)\n  + 0 1 0 0  (4)\n  ---------\n    1 0 0 1  (-7) \u00a1ERROR GRAVE!\n</code></pre> Dos n\u00fameros positivos han generado un negativo. Esto es Overflow.</p> <p>\u00bfQui\u00e9n detecta el error? *   Hardware (ALU): SIEMPRE detecta el desbordamiento (activa un flag de estado interno). *   Software (C++): Por defecto IGNORA esta se\u00f1al para ganar velocidad. El programa contin\u00faa ejecut\u00e1ndose con el valor err\u00f3neo sin avisar (comportamiento indefinido o wrap-around).</p>"},{"location":"Representacion_de_la_informacion.html#representaci\u00f3n-de-enteros-en-lenguajes-de-programaci\u00f3n","title":"Representaci\u00f3n de Enteros en Lenguajes de Programaci\u00f3n","text":"<p>La representaci\u00f3n interna de los n\u00fameros enteros depende dr\u00e1sticamente del lenguaje. Mientras que C++ ofrece control sobre el hardware (tama\u00f1os fijos), Python ofrece abstracci\u00f3n matem\u00e1tica (tama\u00f1os din\u00e1micos).</p>"},{"location":"Representacion_de_la_informacion.html#c","title":"C++","text":"<p>Filosof\u00eda: Eficiencia y cercan\u00eda al Hardware.</p> <ul> <li>Tama\u00f1os fijos: C++ permite trabajar con enteros de 8, 16, 32 o 64 bits.</li> <li>Tipos: Soporta <code>signed</code> (Complemento a 2) y <code>unsigned</code> (Binario Puro).</li> </ul> <p>Este dise\u00f1o obedece al concepto de POD (Plain Old Data): los tipos b\u00e1sicos de C++ son datos crudos, secuencias de bits en memoria sin metadatos ni cabeceras ocultas. Un <code>int</code> de 32 bits ocupa exactamente 32 bits en RAM, nada m\u00e1s.</p> <p>Ejemplo: Representaci\u00f3n en Memoria (32 bits) <pre><code>int x = 23;  // Memoria: 00000000 ... 00010111\nint x = -23; // Memoria: 11111111 ... 11101001 (Complemento a 2)\n</code></pre></p> <p>Enteros sin Signo (<code>unsigned</code>) Eliminan el bit de signo para duplicar el rango positivo (\\([0, 2^{32}-1]\\) en 32 bits).</p> <p>Riesgo de Desbordamiento</p> <p>Haciendo honor a su filosof\u00eda de eficiencia, C++ ignora el flag de overflow de la ALU y no realiza comprobaciones adicionales.</p> <p>Si se supera el rango m\u00e1ximo, la variable simplemente da la vuelta (wrap-around) y contin\u00faa con un valor incorrecto sin avisar. \u00a1El programa no se detiene ni genera una excepci\u00f3n!</p> <p>Por ejemplo, si sumamos 1 al m\u00e1ximo valor entero con signo de 32 bits (\\(2.147.483.647\\)), obtendremos el m\u00ednimo negativo (\\(-2.147.483.648\\)). </p>"},{"location":"Representacion_de_la_informacion.html#python","title":"Python","text":"<p>Filosof\u00eda: Comodidad y Abstracci\u00f3n.</p> <ul> <li>Precisi\u00f3n Arbitraria: En Python 3, los enteros (<code>int</code>) crecen din\u00e1micamente tanto como la RAM permita. \u00a1No existe overflow aritm\u00e9tico!</li> <li>Sin tipos <code>unsigned</code>: Todos los enteros tienen signo.</li> </ul> <p>Estructura Interna (Precisi\u00f3n Arbitraria o BigNum) A diferencia de C++, donde un entero es una caja de tama\u00f1o fijo (si metes algo m\u00e1s grande, se rompe), en Python un entero es como un acorde\u00f3n que se estira seg\u00fan se necesite.</p> <p>Para lograr esto, Python no guarda el n\u00famero tal cual lo hace el procesador. En su lugar, trocea el n\u00famero grande en peque\u00f1os bloques de 30 bits y los trata como si fueran d\u00edgitos de una base num\u00e9rica gigante (Base \\(2^{30}\\)).</p> <p>Matem\u00e1ticamente, funciona igual que nuestro sistema decimal (donde sumamos unidades, decenas, centenas...), pero usando potencias de \\(2^{30}\\): $\\(N = \\sum_{i=0} d_i \\cdot (2^{30})^i = d_0 + d_1 \\cdot 2^{30} + d_2 \\cdot 2^{60} + \\dots\\)$</p> <p>Ejemplo Pr\u00e1ctico</p> <p>Imagina un n\u00famero enorme como <code>123456789101112131415</code> (requiere unos 70 bits). 1.  Como no cabe en un registro de CPU de 64 bits, Python lo descompone. 2.  Calcula sus d\u00edgitos en base \\(2^{30}\\) y obtiene tres bloques: <code>437976919</code>, <code>87719511</code> y <code>107</code>. 3.  Guarda internamente una lista con la magnitud: <code>[437976919, 87719511, 107]</code>.</p> <p>Utiliza un campo extra para indicar la longitud de esa lista y el signo: almacenar\u00e1 3 si es positivo o -3 si es negativo. Este valor se almacena en Complemento a 2. El signo de este campo es el signo del n\u00famero original y su valor absoluto determina cuantos bloques (d\u00edgitos) tiene la lista.</p> <p>Si multiplicas este n\u00famero por 1000 y el resultado necesita m\u00e1s espacio, Python simplemente a\u00f1ade un cuarto d\u00edgito a la lista.</p> <p>El precio de la magia</p> <p>Mientras que en C++ sumar dos n\u00fameros es una sola instrucci\u00f3n (nanosegundos), en Python implica ejecutar un peque\u00f1o programa que recorre estas listas, gestiona los acarreos y asigna memoria. Es mucho m\u00e1s c\u00f3modo, pero mucho m\u00e1s lento.</p>"},{"location":"Representacion_de_la_informacion.html#4-representaci\u00f3n-de-n\u00fameros-reales","title":"4. Representaci\u00f3n de N\u00fameros Reales","text":"<p>Un n\u00famero real consta de una parte entera y otra fraccionaria, m\u00e1s el signo. Existen dos opciones de representaci\u00f3n: coma fija o coma flotante.</p>"},{"location":"Representacion_de_la_informacion.html#la-coma-fija-fixed-point","title":"La Coma Fija (Fixed Point)","text":"<p>Se asigna una cantidad fija de d\u00edgitos para la parte entera y una cantidad fija para la parte fraccionaria.</p> <p>Obviando por el momento el signo, si disponemos de 8 bits y reservamos 5 bits para la parte entera y 3 para la fraccionaria, el n\u00famero \\(21.75_{10}\\) (\\(10101_2\\) entero y \\(0.11_2\\) fraccionario) se almacenar\u00eda como <code>10101110</code>.</p> <p>Al usar la notaci\u00f3n en coma fija, queda muy limitado el rango de cantidades a representar, aunque todas ellas tienen la misma resoluci\u00f3n (distancia entre valores).</p> <p>Ejemplo: 8 bits (5 bits parte entera y 3 bits parte fraccionaria). Sin tener en cuenta el signo:</p> <ul> <li>No podremos representar n\u00fameros enteros mayores o iguales que \\(32\\) (\\(2^5\\)).</li> <li>Ni n\u00fameros m\u00e1s peque\u00f1os que \\(0.125\\) (\\(2^{-3}\\)).</li> <li>La resoluci\u00f3n fija entre dos valores consecutivos es \\(0.125\\) (\\(2^{-3}\\)).</li> </ul> <p>Uso actual e Implementaci\u00f3n Real: Enteros Escalados</p> <p>Aunque simple, las limitaciones conceptuales de rango hacen que la coma fija rara vez se use para c\u00e1lculos cient\u00edficos generales. Sin embargo, sigue siendo el est\u00e1ndar en dos \u00e1reas cr\u00edticas:</p> <ol> <li>Sistemas Financieros: La coma flotante comete errores min\u00fasculos de redondeo (ej. <code>0.1 + 0.2</code> a menudo da <code>0.30000000000000004</code>). En banca, un c\u00e9ntimo perdido es inaceptable.</li> <li>Microcontroladores y DSP: Muchos procesadores peque\u00f1os (como los de una lavadora o un juguete) no tienen circuiter\u00eda compleja para decimales (FPU) por ser cara y lenta.</li> </ol> <p>\u00bfEl secreto? Trabajar solo con ENTEROS (Scaled Integers). En la pr\u00e1ctica, estas m\u00e1quinas no saben que existen decimales. El programador decide de antemano (en tiempo de dise\u00f1o) cu\u00e1ntos bits dedicar\u00e1 a la parte fraccionaria y mantiene esa decisi\u00f3n fija para todas las operaciones. Simplemente escala los valores:</p> <ul> <li>Objetivo: Guardar \\(19.95\\).</li> <li>Factor de escala: \\(\\times 100\\) (para tener 2 decimales de precisi\u00f3n).</li> <li>Microcontrolador: Calcula \\(1995\\) y lo guarda en un entero normal (<code>int</code>).</li> </ul> <p>Si luego quiere sumar \\(5.00\\), el micro suma \\(500\\). $$ 1995 + 500 = 2495 $$ Finalmente, para mostrarlo al usuario, el programador escribe el c\u00f3digo para pintar una coma dos posiciones a la izquierda: \\(24.95\\). \u00a1El procesador solo sum\u00f3 enteros!</p>"},{"location":"Representacion_de_la_informacion.html#la-coma-flotante-floating-point","title":"La Coma Flotante (Floating Point)","text":"<p>Esta es la soluci\u00f3n adoptada universalmente en la inform\u00e1tica moderna para uso general. Permite cubrir un rango de valores gigantesco sacrificando precisi\u00f3n absoluta en los decimales menos significativos. El nombre proviene de que la coma flota (se mueve), permitiendo representar con la misma cantidad de bits n\u00fameros muy grandes (con poca precisi\u00f3n decimal) o n\u00fameros muy peque\u00f1os (con mucha precisi\u00f3n).</p> <p>Contexto Hist\u00f3rico: El Caos Previo a 1985</p> <p>Hasta finales del siglo XX (concretamente antes de 1985), no exist\u00eda un est\u00e1ndar unificado. Cada fabricante de hardware (IBM, DEC, Cray, VAX...) dise\u00f1aba su propio formato de coma flotante, con sus propias reglas de redondeo y tama\u00f1os de exponente.</p> <p>Esto provocaba graves problemas de portabilidad: un mismo programa cient\u00edfico en C o Fortran pod\u00eda arrojar resultados num\u00e9ricos distintos dependiendo de si se ejecutaba en un mainframe IBM o en un ordenador personal. Esta Torre de Babel num\u00e9rica imped\u00eda el intercambio fiable de datos y oblig\u00f3 a la industria a consensuar una norma com\u00fan.</p>"},{"location":"Representacion_de_la_informacion.html#fundamentos-notaci\u00f3n-cient\u00edfica","title":"Fundamentos: Notaci\u00f3n Cient\u00edfica","text":"<p>Antes de entrar en el est\u00e1ndar, recordemos que un n\u00famero real \\(r\\) en coma flotante se representa conceptualmente usando notaci\u00f3n cient\u00edfica:</p> \\[ r = \\pm m \\cdot b^e \\] <p>donde:</p> <ul> <li>\\(m\\) es el significando o mantisa: un coeficiente formado por un n\u00famero real con una sola cifra entera (distinta de cero) seguida por una coma y varias cifras fraccionarias.</li> <li>\\(b\\) es la base del sistema de numeraci\u00f3n (\\(10\\) en decimal, \\(2\\) en binario).</li> <li>\\(e\\) es el exponente entero al que se eleva la base.</li> </ul> <p>Comparativa: Base 10 vs Base 2</p> <p>En Decimal (Base 10): Supongamos el n\u00famero \\(-0.00345\\). *   Normalizado: \\(-3.45 \\times 10^{-3}\\) *   Mantisa: \\(3.45\\) *   Exponente: \\(-3\\)</p> <p>En Binario (Base 2): Supongamos el n\u00famero \\(0.001101_2\\) (\\(0.203125_{10}\\)). *   Desplazamos la coma hasta dejar un solo '1' a la izquierda: \\(1.101 \\times 2^{-3}\\). *   Mantisa: \\(1.101\\) (Nota: En binario, la \u00fanica cifra entera posible no nula es 1). *   Exponente: \\(-3\\).</p> <p>El est\u00e1ndar IEEE 754 simplemente define c\u00f3mo empaquetar estos tres valores (signo, exponente y mantisa) dentro de una palabra de 32 o 64 bits.</p>"},{"location":"Representacion_de_la_informacion.html#est\u00e1ndar-ieee-754","title":"Est\u00e1ndar IEEE 754","text":"<p>Pr\u00e1cticamente todos los computadores modernos siguen este est\u00e1ndar. Se basa en adaptar la notaci\u00f3n cient\u00edfica al mundo binario:</p> \\[ V = (-1)^s \\cdot (1 + m) \\cdot 2^{e - Bias} \\] <ul> <li>\\(s\\) (Signo): 1 bit (\\(0 \\to +\\), \\(1 \\to -\\)).</li> <li>\\(m\\) (Mantisa): Parte fraccionaria normalizada (\\(1.xxxxx...\\)).</li> <li>\\(e\\) (Exponente): Entero representado en exceso (Bias).</li> </ul> Precisi\u00f3n Bits Totales Signo Exponente (\\(k\\)) Mantisa (\\(p\\)) Exceso (Bias) Cifras Decimales Simple (<code>float</code>) 32 1 8 23 127 ~7 Doble (<code>double</code>) 64 1 11 52 1023 ~16 <p>Estructura del est\u00e1ndar IEEE 754</p>"},{"location":"Representacion_de_la_informacion.html#caracter\u00edsticas-clave","title":"Caracter\u00edsticas Clave","text":"<ol> <li>Exponente en Exceso: Se almacena sumando un sesgo (\\(Bias\\)) al exponente real.<ul> <li>C\u00e1lculo del Bias: Depende del n\u00famero de bits del exponente (\\(k\\)):     $$ Bias = 2^{k-1} - 1 $$<ul> <li>Simple precisi\u00f3n (\\(k=8\\)): \\(2^{7} - 1 = 128 - 1 = 127\\).</li> <li>Doble precisi\u00f3n (\\(k=11\\)): \\(2^{10} - 1 = 1024 - 1 = 1023\\).</li> </ul> </li> <li>\\(E_{guardado} = E_{real} + Bias\\).</li> <li>Permite comparar los exponentes como enteros sin signo, facilitando la ordenaci\u00f3n r\u00e1pida de n\u00fameros.</li> </ul> </li> <li>Bit Impl\u00edcito: En la notaci\u00f3n normalizada binaria, el n\u00famero siempre empieza por <code>1.</code> (ej. <code>1.011...</code>). Para ahorrar espacio, ese <code>1</code> no se guarda, se asume impl\u00edcitamente.</li> </ol>"},{"location":"Representacion_de_la_informacion.html#orden-de-almacenamiento-y-comparaci\u00f3n","title":"Orden de Almacenamiento y Comparaci\u00f3n","text":"<p>El orden f\u00edsico de los bits en la memoria es estricto: primero el Signo, seguido del Exponente, seguido de la Mantisa.</p> <p><code>[Signo]</code> | <code>[Exponente]</code> | <code>[Mantisa]</code></p> <p>El orden no es balad\u00ed: permite que los algoritmos de comparaci\u00f3n (y por tanto los chips que los implementan) dise\u00f1ados para n\u00fameros enteros sean tambi\u00e9n v\u00e1lidos (en su mayor\u00eda) para esta representaci\u00f3n de n\u00fameros reales.</p> <p>Terminolog\u00eda T\u00e9cnica</p> <p>En alguna bibliograf\u00eda cl\u00e1sica se utiliza la palabra caracter\u00edstica para distinguir el valor almacenado (con el sesgo sumado) del exponente real matem\u00e1tico.</p> <p>Al colocar el exponente en los bits m\u00e1s significativos (a la izquierda de la mantisa), logramos que un n\u00famero con mayor orden de magnitud parezca visual y num\u00e9ricamente mayor que uno con menor orden de magnitud, independientemente de sus decimales.</p> <p>Pero para que este truco funcione, es cr\u00edtico que el exponente use representaci\u00f3n en EXCESO (que siempre es positivo) y NO en Complemento a 2.</p> <p>Ejemplo Simplificado: La importancia del Exceso vs C2 Comparemos un n\u00famero grande positivo (Exponente \\(+1\\)) con un n\u00famero peque\u00f1o (Exponente \\(-1\\)). *   \\(A\\): \\(1.0 \\times 2^{+1}\\) (Grande) *   \\(B\\): \\(1.0 \\times 2^{-1}\\) (Peque\u00f1o)</p> <p>Caso 1: Usando Exponente en Complemento a 2 (Falso) *   \\(+1\\) en C2 (3 bits) \\(\\to\\) <code>001</code> *   \\(-1\\) en C2 (3 bits) \\(\\to\\) <code>111</code> *   Al comparar los bits como enteros sin signo: <code>111</code> (\\(7\\)) &gt; <code>001</code> (\\(1\\)). *   Resultado: \u00a1El hardware pensar\u00eda err\u00f3neamente que el n\u00famero peque\u00f1o (\\(B\\)) es mayor que el grande (\\(A\\))!</p> <p>Caso 2: Usando Exponente en Exceso (Real - IEEE 754) Supongamos un Bias de 3 (\\(2^{3-1}-1\\)). *   Exponente real \\(+1\\) \\(\\to\\) Guardado: \\(1 + 3 = 4\\) (<code>100</code>) *   Exponente real \\(-1\\) \\(\\to\\) Guardado: \\(-1 + 3 = 2\\) (<code>010</code>) *   Comparaci\u00f3n de bits: <code>100</code> (\\(4\\)) &gt; <code>010</code> (\\(2\\)). *   Resultado: <code>A &gt; B</code>. CORRECTO.</p> <p>Dise\u00f1o Inteligente</p> <p>Gracias al uso del Exceso, los exponentes negativos se representan con c\u00f3digos binarios peque\u00f1os (ej. 00...) y los positivos con c\u00f3digos grandes (ej. 11...), preservando el orden natural de los n\u00fameros enteros. Esto permite usar comparadores r\u00e1pidos de enteros en la ALU.</p> <p>Ejemplo: Convertir 13.125 a IEEE 754 (Simple)</p> <ol> <li>Binario: \\(13.125_{10} = 1101.001_2\\)</li> <li>Normalizar: \\(1.101001 \\times 2^3\\)</li> <li>Componentes:<ul> <li>Signo: \\(0\\) (+)</li> <li>Exponente Real: \\(3\\). Exponente guardado: \\(3 + 127 = 130 \\to 10000010_2\\).</li> <li>Mantisa: \\(101001...\\) (rellenar con ceros a la derecha hasta 23 bits).</li> </ul> </li> <li>Resultado Hex: <ul> <li>Binario: <code>0 10000010 1010010000...</code></li> <li>Agrupando: <code>0100 0001 0101 0010 0000...</code> \\(\\to\\) <code>4 1 5 2 0 ...</code> </li> <li>Hexadecimal: <code>0x41520000</code></li> </ul> </li> </ol> <p>Ejemplo Inverso: Decodificar 0xC1480000 a Decimal</p> <ol> <li>Binario: <code>0xC1480000</code> \\(\\to\\) <code>1100 0001 0100 1000 0000...</code></li> <li>Separar campos:<ul> <li>Signo (1 bit): <code>1</code> \\(\\to\\) Negativo (\\(-\\)).</li> <li>Exponente (8 bits): <code>10000010</code> \\(\\to\\) \\(130_{10}\\).</li> <li>Mantisa (23 bits): <code>1001000...</code></li> </ul> </li> <li>C\u00e1lculos:<ul> <li>Exponente Real: \\(E = 130 - 127 (\\text{Bias}) = 3\\).</li> <li>Mantisa con impl\u00edcito: \\(1.1001000...\\)</li> </ul> </li> <li>Valor:<ul> <li>\\((-1) \\times 1.1001_2 \\times 2^3\\)</li> <li>Desplazar la coma 3 sitios a la derecha: \\(-1100.1_2\\)</li> <li>Convertir a decimal: $-(8 + 4 + 0.5) = $ \\(-12.5\\)</li> </ul> </li> </ol>"},{"location":"Representacion_de_la_informacion.html#casos-especiales","title":"Casos Especiales","text":"<p>El est\u00e1ndar reserva los valores de exponente m\u00ednimo (todos 0s) y m\u00e1ximo (todos 1s) para casos excepcionales. Permite representar el Cero (que mantiene signo), indicar desbordamientos mediante Infinito (\\(\\pm \\infty\\)) y se\u00f1alar errores matem\u00e1ticos (como divisiones imposibles o ra\u00edces de negativos) con el valor NaN (Not a Number).</p> Exponente Mantisa Significado Todos 0 Todos 0 Cero (\\(\\pm 0\\)) Todos 0 \\(\\neq 0\\) N\u00fameros desnormalizados (muy peque\u00f1os) Todos 1 Todos 0 Infinito (\\(\\pm \\infty\\)) Todos 1 \\(\\neq 0\\) NaN (Not a Number) <p>Casos especiales de la norma IEEE 754</p> <p>\u00bfQu\u00e9 operaci\u00f3n provoca qu\u00e9?</p> <p>Es com\u00fan confundir qu\u00e9 genera un Infinito y qu\u00e9 genera un NaN. La ALU sigue reglas matem\u00e1ticas de l\u00edmites:</p> <ul> <li>Infinito (\\(\\pm \\infty\\)): Aparece cuando el resultado crece sin l\u00edmite o supera la capacidad de almacenamiento.<ul> <li>\\(8.0 / 0.0 \\to +\\infty\\) (Cualquier n\u00famero distinto de cero dividido entre cero).</li> <li>\\(10^{308} \\times 10 \\to +\\infty\\) (Desbordamiento hacia arriba).</li> </ul> </li> <li>NaN (No es un N\u00famero): Aparece ante indeterminaciones matem\u00e1ticas donde no existe una respuesta l\u00f3gica \u00fanica.<ul> <li>\\(0.0 / 0.0 \\to \\text{NaN}\\) (Indeterminaci\u00f3n)</li> <li>\\(\\infty - \\infty \\to \\text{NaN}\\) (Indeterminaci\u00f3n)</li> <li>\\(\\sqrt{-5} \\to \\text{NaN}\\) (Imposible en reales)</li> </ul> </li> </ul> <p>La colocaci\u00f3n de los patrones de bits en el exponente la realiza el hardware (la Unidad de Coma Flotante o FPU) en tiempo real mediante circuitos que monitorizan las excepciones antes o durante la operaci\u00f3n. Por ejemplo, para \\(\\sqrt{-5}\\) se activa la excepci\u00f3n Invalid Operation y la FPU fuerza el exponente a unos (<code>1...1</code>) y pone basura en la mantisa (cualquier valor \\(\\neq 0\\)). </p>"},{"location":"Representacion_de_la_informacion.html#precisi\u00f3n","title":"Precisi\u00f3n","text":"<p>Los n\u00fameros reales en el ordenador son un subconjunto discreto de los reales matem\u00e1ticos.</p>"},{"location":"Representacion_de_la_informacion.html#n\u00famero-de-bits-de-la-mantisa","title":"N\u00famero de bits de la mantisa","text":"<p>La influencia de disponer de un bit a mayores en la mantisa supone que la distancia entre 2 n\u00fameros consecutivos representables se divide por 2. Por tanto, el t\u00e9rmino doble precisi\u00f3n no es riguroso: la precisi\u00f3n que ofrece el formato de 64 bits es inmensamente mayor. Pasa de 23 a 52 bits de mantisa, mejorando la resoluci\u00f3n en un factor de \\(2^{29}\\), no solo el doble.</p>"},{"location":"Representacion_de_la_informacion.html#distribuci\u00f3n-en-la-recta-real","title":"Distribuci\u00f3n en la recta real","text":"<p>Los n\u00fameros no est\u00e1n uniformemente distribuidos sobre la recta real, sino que est\u00e1n m\u00e1s pr\u00f3ximos cerca del origen (exponentes m\u00e1s peque\u00f1os) y m\u00e1s separados a medida que nos alejamos de \u00e9l (exponentes m\u00e1s grandes).</p> <p></p> Distribuci\u00f3n de los float's en la recta real <p></p> <p>Ejemplo: Densidad constante, Precisi\u00f3n variable</p> <p>En cada intervalo definido por una potencia de 2 (ej. entre \\(2^0\\) y \\(2^1\\), o entre \\(2^1\\) y \\(2^2\\)), el exponente se mantiene fijo. Por tanto, los \u00fanicos valores distintos que podemos representar dependen de las combinaciones de la Mantisa.</p> <p>Como en IEEE 754 de 32 bits tenemos 23 bits de mantisa, existen exactamente \\(2^{23}\\) (unos 8.3 millones) de combinaciones (pasos) dentro de cada intervalo de potencias.</p> <ul> <li> <p>Intervalo \\([1, 2)\\): La distancia total es \\(1\\).     Al dividir este espacio de 1 unidad en \\(2^{23}\\) pasos, el salto o resoluci\u00f3n entre un n\u00famero y el siguiente es:     $$ \\text{Salto} = \\frac{1}{2^{23}} = 2^{-23} \\approx 0.000000119 $$</p> </li> <li> <p>Intervalo \\([2, 4)\\): La distancia total es \\(2\\) (\\(4-2\\)).     Sigue habiendo los mismos \\(2^{23}\\) escalones disponibles. Al repartirlos en un espacio el doble de grande, el salto es el doble:     $$ \\text{Salto} = \\frac{2}{2^{23}} = 2^{1-23} = 2^{-22} \\approx 0.000000238 $$</p> </li> <li> <p>Intervalo \\([1024, 2048)\\): La distancia es \\(1024\\) (\\(2^{10}\\)).     $$ \\text{Salto} = \\frac{2^{10}}{2^{23}} = 2^{10-23} = 2^{-13} \\approx 0.000122 $$</p> </li> </ul> <p>Conclusi\u00f3n: Cuanto m\u00e1s grande es el n\u00famero, mayores son los saltos (peor precisi\u00f3n absoluta), manteniendo el error relativo constante.</p> <p>La concentraci\u00f3n en \\([0, 1]\\) y \\([-1, 0]\\)</p> <p>Una consecuencia fascinante de esta distribuci\u00f3n logar\u00edtmica es la inmensa cantidad de valores concentrados cerca del cero. Dado que el exponente en IEEE 754 de 32 bits var\u00eda aproximadamente entre \\(-126\\) y \\(+127\\), casi la mitad de los valores posibles del exponente son negativos. Esto implica que aproximadamente el 50% de todos los n\u00fameros positivos que un ordenador puede representar residen en el intervalo \\((0, 1)\\).</p> <p>Por simetr\u00eda, ocurre exactamente lo mismo con los n\u00fameros negativos: el 50% de ellos se concentra en el intervalo \\((-1, 0)\\).</p> <p>Por esta raz\u00f3n, muchos algoritmos num\u00e9ricos (como en el entrenamiento de modelos de Inteligencia Artificial o procesamiento de imagen) normalizan los datos para trabajar dentro del rango \\([0, 1]\\) o \\([-1, 1]\\). Al mantener los c\u00e1lculos en esta zona densa, se aprovecha la m\u00e1xima resoluci\u00f3n disponible y se minimizan los errores de redondeo.</p>"},{"location":"Representacion_de_la_informacion.html#redondeo","title":"Redondeo","text":"<p>N\u00fameros simples como \\(0.1_{10}\\) tienen representaci\u00f3n peri\u00f3dica infinita en binario (como \\(1/3\\) en decimal), provocando errores de precisi\u00f3n acumulativos.</p> <p>Ejemplo: El error de representaci\u00f3n de 0.1</p> <p>Veamos qu\u00e9 pasa representando el valor \\(0.1_{10}\\) en simple precisi\u00f3n (32 bits).</p> <p>1. Transformaci\u00f3n a Binario: La parte fraccionaria \\(0.1\\) en binario es una fracci\u00f3n peri\u00f3dica: $$ 0.1_{10} = 0.0\\,\\overline{0011}\\,_2 = 0.0001100110011..._2 $$</p> <p>2. Signo y Normalizaci\u00f3n: *   Signo: Positivo \\(\\to \\mathbf{0}\\). *   Notaci\u00f3n Cient\u00edfica: Desplazamos la coma 4 posiciones a la derecha:     $$ 1.100110011..._2 \\times 2^{-4} $$</p> <p>3. Mantisa (Redondeo): Necesitamos quedarnos con 23 bits despu\u00e9s de la coma.</p> <ul> <li>Secuencia: <code>10011001100110011001100</code> <code>1</code>... (el bit 24 es un 1).</li> <li>Aplicamos redondeo al par m\u00e1s cercano (o simplemente redondeo hacia arriba en este caso simple): sumamos 1 al bit 23 (\\(0 \\to 1\\)).</li> <li>Mantisa Guardada (\\(M\\)): \\(\\mathbf{10011001100110011001101}\\)</li> </ul> <p>4. Exponente: *   \\(E_{real} = -4\\). *   \\(E_{guardado} = -4 + 127 = 123_{10} = \\mathbf{01111011}_2\\).</p> <p>5. Resultado final en memoria (Hex <code>0x3DCCCCCD</code>): <code>0</code> <code>01111011</code> <code>10011001100110011001101</code></p> <p>Comprobaci\u00f3n: \u00bfQu\u00e9 n\u00famero hemos guardado REALMENTE? Hagamos el proceso inverso para ver el error cometido.</p> <ul> <li>Mantisa \\(= 1 + \\left( \\frac{5033165}{2^{23}} \\right) \\approx 1.6000000238...\\)</li> <li>Exponente \\(= 2^{-4} = \\frac{1}{16} = 0.0625\\)</li> <li>Valor \\(= 1.6000000238... \\times 0.0625\\)</li> </ul> <p>Resultado Real: \\(0.100000001490116119384765625\\)</p> <p>El ordenador no ha guardado \\(0.1\\), sino un n\u00famero ligeramente mayor. Aunque el error es min\u00fasculo (aprox. \\(1.49 \\cdot 10^{-9}\\)), si sumamos \\(0.1\\) millones de veces, este error se acumula y se hace visible.</p> <p>Ejemplo catastr\u00f3fico: Fallo del misil Patriot (1991)</p> <p>Durante la Guerra del Golfo, una bater\u00eda de misiles Patriot en Dhahran (Arabia Saud\u00ed) fall\u00f3 al interceptar un Scud iraqu\u00ed y murieron 28 soldados. El fallo no se debi\u00f3 al tiempo de vuelo del misil, sino al tiempo que la bater\u00eda llevaba encendida.</p> <ul> <li>El Error de Base: El sistema med\u00eda el tiempo en d\u00e9cimas de segundo y lo multiplicaba por \\(0.1\\) para obtener segundos. Como \\(0.1\\) tiene infinitos decimales en binario, el registro de 24 bits truncaba el valor, cometiendo un error de \\(0.000000095\\) s.</li> <li>La Acumulaci\u00f3n (Reloj Global): El sistema no reseteaba el reloj al detectar un misil, sino que usaba el tiempo absoluto desde el arranque (100 horas) para todos sus c\u00e1lculos de seguimiento.     Aunque el misil Scud acababa de aparecer, el ordenador calculaba su posici\u00f3n usando este tiempo absoluto corrupto. Al multiplicar el error base por cada d\u00e9cima de segundo de las 100 horas, el desfase era enorme:     $$ 100 \\text{ h} \\times 3600 \\frac{\\text{s}}{\\text{h}} \\times 10 \\frac{\\text{d\u00e9cimas}}{\\text{s}} \\times 0.000000095 \\text{ s} \\approx \\mathbf{0.34 \\text{ segundos}} $$</li> <li> <p>El Fallo de Software (Bug de Precisi\u00f3n Mixta): si todo el sistema hubiera tenido el mismo error, NO habr\u00eda pasado nada, porque los errores se habr\u00edan cancelado al restar tiempos (\\(t_2 - t_1\\)).     El desastre ocurri\u00f3 porque se instal\u00f3 una actualizaci\u00f3n de software que correg\u00eda el problema de precisi\u00f3n en una subrutina, pero se olvidaron de corregirlo en otra.</p> <ul> <li>Para predecir d\u00f3nde deber\u00eda estar el misil, se us\u00f3 la subrutina antigua que convert\u00eda el tiempo absoluto (100h) truncando los datos (con el error acumulado de 0.34s).</li> <li>Para procesar el dato fresco del radar, se convertir\u00eda ese mismo tiempo absoluto de 100h usando el nuevo algoritmo de alta precisi\u00f3n (sin apenas error).</li> </ul> <p>Al comparar una posici\u00f3n calculada con el reloj malo contra una posici\u00f3n real con el reloj bueno, los errores no se cancelaron. El ordenador calcul\u00f3 una zona de b\u00fasqueda err\u00f3nea y no encontr\u00f3 nada.</p> <p>La Distancia Fatal: En ese breve lapso de desfase (\\(0.34 \\text{ s}\\)), un misil Scud viajando a Match 5 (\\(1676 \\text{ m/s}\\)) recorre una distancia enorme: $$ \\Delta x = 0.34 \\text{ s} \\times 1676 \\text{ m/s} \\approx \\mathbf{570 \\text{ metros}} $$ Al buscar el misil a m\u00e1s de medio kil\u00f3metro de su posici\u00f3n real, el radar lo perdi\u00f3, lo clasific\u00f3 como falsa alarma y no dispar\u00f3.</p> </li> </ul>"},{"location":"Representacion_de_la_informacion.html#representaci\u00f3n-de-reales-en-lenguajes-de-programaci\u00f3n","title":"Representaci\u00f3n de Reales en Lenguajes de Programaci\u00f3n","text":"<p>Al igual que ocurre con los enteros, la gesti\u00f3n de los n\u00fameros reales var\u00eda seg\u00fan la filosof\u00eda del lenguaje, aunque en este caso las diferencias son menores debido a la omnipresencia del est\u00e1ndar IEEE 754.</p>"},{"location":"Representacion_de_la_informacion.html#c_1","title":"C++","text":"<p>Filosof\u00eda: Eficiencia y acceso directo al hardware.</p> <p>C++ expone directamente los tipos de datos que soporta la FPU del procesador. El programador debe elegir el compromiso entre memoria/velocidad y precisi\u00f3n.</p> <p>Al ser tipos POD, su representaci\u00f3n en memoria es exactamente el patr\u00f3n de bits del est\u00e1ndar IEEE 754, sin sobrecarga adicional.</p> <ul> <li><code>float</code> (Simple Precisi\u00f3n): 32 bits (IEEE 754). \u00datil para gr\u00e1ficos en 3D (juegos) o arrays gigantes donde el ahorro de memoria es crucial. Precisi\u00f3n de ~7 d\u00edgitos decimales.</li> <li><code>double</code> (Doble Precisi\u00f3n): 64 bits (IEEE 754). Es el est\u00e1ndar para c\u00e1lculos cient\u00edficos y la opci\u00f3n por defecto. Precisi\u00f3n de ~15-16 d\u00edgitos decimales.</li> <li><code>long double</code>: Extensi\u00f3n (a menudo 80 bits o 128 bits) para mayor precisi\u00f3n, aunque m\u00e1s lenta y dependiente de la arquitectura.</li> </ul> <p>Como ya hemos apuntado anteriormente, el t\u00e9rmino \"Doble Precisi\u00f3n\" es en realidad una herencia del hardware: se llama as\u00ed porque ocupa el doble de memoria (64 bits frente a 32) y ofrece aproximadamente el doble de cifras significativas decimales (pasamos de ~7 a ~16).</p> <p>Sin embargo, matem\u00e1ticamente el nombre se queda muy corto y puede inducir a error. Al pasar de 23 a 52 bits de mantisa, ganamos 29 bits extra de informaci\u00f3n. Esto significa que la resoluci\u00f3n (la cantidad de escalones que podemos distinguir) no se multiplica por 2, sino por \\(2^{29}\\). Es decir, es m\u00e1s de 500 millones de veces m\u00e1s preciso en t\u00e9rminos de densidad de valores.</p> <p>Ejemplo: <pre><code>float  a = 0.1f; // Se guarda como 0.10000000149... (Error en 8\u00ba decimal)\ndouble b = 0.1;  // Se guarda con mucha m\u00e1s precisi\u00f3n (Error en 17\u00ba decimal)\n</code></pre></p>"},{"location":"Representacion_de_la_informacion.html#python_1","title":"Python","text":"<p>Filosof\u00eda: Simplicidad y Unificaci\u00f3n.</p> <p>A diferencia de los enteros (que eran m\u00e1gicos y crec\u00edan infinitamente hasta los l\u00edmites de la memoria), los reales en Python NO tienen precisi\u00f3n arbitraria por defecto. </p> <ul> <li>Tipo \u00fanico <code>float</code>: En Python estandar, un <code>float</code> corresponde siempre a un <code>double</code> de C (64 bits IEEE 754). No existe tipo de 32 bits nativo para ahorrar memoria (salvo usando librer\u00edas externas como NumPy).</li> <li>Limitaciones: Sufren los mismos problemas de redondeo y desbordamiento que el <code>double</code> de C++.</li> </ul> <p>Comparativa Int vs Float en Python</p> <ul> <li><code>2 ** 1000</code> \\(\\to\\) Calcula el n\u00famero exacto (un entero de cientos de d\u00edgitos).</li> <li><code>2.0 ** 1000</code> \\(\\to\\) Genera <code>OverflowError</code> (o devuelve <code>inf</code>), porque el resultado supera el valor m\u00e1ximo de IEEE 754 (\\(\\approx 1.8 \\times 10^{308}\\)).</li> </ul> <p>Soluciones Standard para Alta Precisi\u00f3n</p> <p>Para software financiero o cient\u00edfico que requiera m\u00e1s precisi\u00f3n que la que ofrece el hardware, Python incluye m\u00f3dulos espec\u00edficos:</p> <ol> <li><code>decimal</code>: Aritm\u00e9tica decimal exacta (base 10). Permite configurar la precisi\u00f3n arbitraria (ej. \"quiero 50 decimales\"). Es lento pero exacto (ideal para dinero).</li> <li><code>fractions</code>: Almacena n\u00fameros racionales como fracci\u00f3n exacta \\(N/D\\) (\\(1/3\\) es 1 y 3, no \\(0.333...\\)).</li> </ol> <p>Consejo de Programaci\u00f3n (V\u00e1lido para todos los lenguajes)</p> <p>Debido a los errores de redondeo (como el del 0.1), NUNCA compares n\u00fameros en coma flotante con igualdad estricta.</p> <ul> <li>Mal: <code>if (resultado == 0.0)</code></li> <li>Bien: <code>if (abs(resultado) &lt; 0.00001)</code> (Usar un margen de tolerancia o \u00e9psilon).</li> </ul>"},{"location":"Representacion_de_la_informacion.html#5-representaci\u00f3n-de-caracteres","title":"5. Representaci\u00f3n de Caracteres","text":"<p>Un ordenador, en su nivel m\u00e1s bajo, no entiende de letras, palabras o frases; solo procesa n\u00fameros binarios. Para que podamos leer y escribir texto en una pantalla, es necesario establecer un puente entre el mundo humano (s\u00edmbolos gr\u00e1ficos) y el mundo digital (n\u00fameros).</p> <p>Esta traducci\u00f3n se basa en tablas de codificaci\u00f3n de caracteres (Character Sets): acuerdos globales que asignan un n\u00famero \u00fanico a cada letra, d\u00edgito o signo de puntuaci\u00f3n.</p>"},{"location":"Representacion_de_la_informacion.html#el-est\u00e1ndar-ascii","title":"El est\u00e1ndar ASCII","text":"<p>El c\u00f3digo ASCII (American Standard Code for Information Interchange) fue el primer est\u00e1ndar universal. Utiliza 7 bits, lo que permite representar \\(2^7 = 128\\) caracteres distintos.</p> <ul> <li>0-31: Caracteres de control (no imprimibles). Ej: Retorno de carro (<code>\\r</code>), salto de l\u00ednea (<code>\\n</code>), tabulador (<code>\\t</code>).</li> <li>32-127: Caracteres imprimibles (letras inglesas, n\u00fameros y signos de puntuaci\u00f3n). El espacio es el 32 y el \u00faltimo es el car\u00e1cter <code>DEL</code> (127).</li> </ul> <p>Caracter\u00edsticas de dise\u00f1o ingeniosas: Los dise\u00f1adores de ASCII ordenaron los caracteres estrat\u00e9gicamente para facilitar el procesamiento por hardware o algoritmos simples:</p> <ol> <li>D\u00edgitos consecutivos y coincidencia binaria: <code>'0'</code> es el 48 (<code>0011 0000</code>), <code>'1'</code> es el 49 (<code>0011 0001</code>)...<ul> <li>Si observas los 4 bits inferiores (el nibble bajo), coinciden exactamente con el valor num\u00e9rico del d\u00edgito (\\(0000_2=0\\), \\(0001_2=1\\)...).</li> <li>Esto permit\u00eda a los antiguos programadores convertir de texto a n\u00famero instant\u00e1neamente sin hacer restas: bastaba con tomar los \u00faltimos 4 bits (operaci\u00f3n <code>AND 00001111</code> o <code>AND 0x0F</code>).</li> </ul> </li> <li>May\u00fasculas y Min\u00fasculas: <ul> <li><code>'A'</code> = 65 (<code>0100 0001</code>)</li> <li><code>'a'</code> = 97 (<code>0110 0001</code>)</li> <li>La \u00fanica diferencia es el bit 5 (\\(32\\)). Para pasar de may\u00fascula a min\u00fascula basta con activar ese bit (operaci\u00f3n <code>OR 32</code>). Para pasar a may\u00fascula, basta con desactivarlo (operaci\u00f3n <code>AND ~32</code>).</li> </ul> </li> </ol> <p></p> Tabla del c\u00f3digo ASCII extendido Latin-1 <p></p> <p>Limitaciones y el Caos del 'ASCII Extendido'</p> <p>ASCII solo cubre el idioma ingl\u00e9s (7 bits). Para dar cabida a otros idiomas (tildes, e\u00f1es, etc.), se utiliz\u00f3 el 8\u00ba bit disponible en el byte, permitiendo 128 caracteres extra (del 128 al 255).</p> <p>El problema es que no exist\u00eda un \u00fanico 'ASCII Extendido', sino docenas de variantes incompatibles llamadas P\u00e1ginas de C\u00f3digos (Code Pages). Dependiendo de la ubicaci\u00f3n geogr\u00e1fica, el sistema operativo usaba una tabla diferente para interpretar esos caracteres extra:</p> <ul> <li>ISO-8859-1 (conocido como Latin-1): El est\u00e1ndar para Europa Occidental. Es el que incluye la '\u00f1', las vocales con tilde y s\u00edmbolos como '\u00bf' o '\u00e7'.</li> <li>ISO-8859-5: Para el alfabeto Cir\u00edlico (Ruso).</li> <li>ISO-8859-7: Para el alfabeto Griego.</li> </ul> <p>Esto provocaba que el intercambio de archivos fuera una pesadilla: si abr\u00edas un texto espa\u00f1ol (Latin-1) en un ordenador configurado en Rusia, el c\u00f3digo binario de la '\u00f1' (\\(241\\)) se visualizaba como el car\u00e1cter cir\u00edlico que ocupaba esa misma posici\u00f3n ('\u0451'), haciendo el texto ilegible. Este fen\u00f3meno de texto distorsionado por mala interpretaci\u00f3n de la codificaci\u00f3n se conoce como mojibake.</p>"},{"location":"Representacion_de_la_informacion.html#unicode","title":"UNICODE","text":"<p>Unicode surge para poner fin al caos de las p\u00e1ginas de c\u00f3digos estableciendo un cat\u00e1logo universal de caracteres. Para entenderlo, es fundamental distinguir dos conceptos que a menudo se confunden:</p> <ol> <li>Code Point (Punto de C\u00f3digo): Es el identificador num\u00e9rico \u00fanico que Unicode asigna a cada concepto (letra, s\u00edmbolo, emoji). Es una abstracci\u00f3n.<ul> <li>Se escribe <code>U+XX...XX</code> (hexadecimal), donde las X son d\u00edgitos.</li> <li>El espacio de c\u00f3digos va actualmente desde <code>U+0000</code> hasta <code>U+10FFFF</code>. Esto permite definir 1.114.112 caracteres diferentes.<ul> <li>\u00bfEst\u00e1n todos usados? \u00a1Ni mucho menos! Actualmente solo hay asignados unos 150.000 caracteres (aprox. el 13%). La inmensa mayor\u00eda del espacio est\u00e1 vac\u00edo y reservado para el futuro (nuevos idiomas, s\u00edmbolos o emojis).</li> </ul> </li> </ul> </li> <li>Codificaci\u00f3n (Encoding): Es la regla o algoritmo para convertir ese n\u00famero abstracto (Code Point) en bits reales (0s y 1s) para guardarlos en el disco duro o memoria.</li> </ol>"},{"location":"Representacion_de_la_informacion.html#el-est\u00e1ndar-utf-8","title":"El Est\u00e1ndar UTF-8","text":"<p>Aunque Unicode define el n\u00famero, UTF-8 es la forma m\u00e1s inteligente y popular de guardarlo, usada en m\u00e1s del 98% de la Web.</p> <ul> <li>Permite representar TODOS los Code Points de Unicode (del <code>U+0000</code> al <code>U+10FFFF</code>).</li> <li>Su genialidad radica en ser de longitud variable: en lugar de dar el mismo espacio a todos los caracteres, asigna menos bits a los m\u00e1s comunes y m\u00e1s bits a los m\u00e1s raros.</li> </ul> Rango Unicode (Hex) Tama\u00f1o UTF-8 Estructura de los bits (Plantilla) Uso t\u00edpico <code>0000</code> - <code>007F</code> 1 Byte <code>0xxxxxxx</code> Ingl\u00e9s (ASCII original) <code>0080</code> - <code>07FF</code> 2 Bytes <code>110xxxxx 10xxxxxx</code> Lat\u00edn con tildes (\u00f1, \u00f3), Griego, Cir\u00edlico <code>0800</code> - <code>FFFF</code> 3 Bytes <code>1110xxxx 10xxxxxx ...</code> Chino, Japon\u00e9s, S\u00edmbolos comunes (Euro \u20ac) <code>10000</code> - <code>10FFFF</code> 4 Bytes <code>11110xxx 10xxxxxx ...</code> Emojis hist\u00f3ricamente recientes, S\u00edmbolos raros <p>Tabla UTF-8</p> <p>Ejemplo Pr\u00e1ctico: De Code Point a Bytes</p> <ol> <li> <p>La letra 'a' <code>U+0061</code> (\\(97_{10}\\)):</p> <ul> <li>Cae en el primer rango (0-127). Se guarda tal cual: <code>01100001</code> (<code>0x61</code>).</li> <li>Nota: Exactamente igual que en ASCII.</li> </ul> </li> <li> <p>La letra '\u00f1' <code>U+00F1</code> (\\(241_{10}\\)):</p> <ul> <li>Valor binario: <code>1111 0001</code> (8 bits).</li> <li>No cabe en el primer rango (necesita 1 byte que empiece por 0). Pasamos al rango de 2 bytes.</li> <li>Plantilla: <code>110xxxxx 10xxxxxx</code>. Tenemos 11 huecos ('x') para rellenar con nuestros bits.</li> <li>Relleno (con ceros a la izquierda):<ul> <li>Nuestros bits: <code>11110001</code> (son 8, faltan 3 para llegar a 11).</li> <li>Rellenamos con ceros por la izquierda: <code>000</code><code>11110001</code>.</li> <li>Distribuimos en los huecos: <code>110</code><code>00011</code> <code>10</code><code>110001</code>.</li> </ul> </li> <li>Resultado Hex: <code>0xC3 0xB1</code>.</li> <li>Curiosidad: Por eso si abres un archivo UTF-8 como si fuera Latin-1, la \u00f1 se ve como dos caracteres extra\u00f1os (\"\u00c3\u00b1\"): el ordenador interpreta <code>0xC3</code> (\"\u00c3\") y <code>0xB1</code> (\"\u00b1\") por separado.</li> </ul> </li> <li> <p>El Euro '\u20ac' <code>U+20AC</code>:</p> <ul> <li>Necesita 3 bytes: <code>0xE2 0x82 0xAC</code>.</li> </ul> </li> <li> <p>El Emoji '\ud83d\ude02' <code>U+1F602</code> (\\(128514_{10}\\)):</p> <ul> <li>5 cifras hexadecimales equivalen a 20 bits (\\(5 \\times 4\\)). La plantilla de 4 bytes de UTF-8 tiene huecos para 21 bits (\\(3+6+6+6\\)). \u00a1Cabe perfectamente!</li> <li>Paso a paso:<ol> <li>Hex <code>1F602</code> a Binario \\(\\to\\) <code>0001 1111 0110 0000 0010</code>.</li> <li>Rellenamos con ceros hasta 21 bits: <code>0000</code><code>1111101100000010</code>.</li> <li>Agrupamos para \"rellenar huecos\": <code>000</code> <code>011111</code> <code>011000</code> <code>000010</code>.</li> <li>Aplicamos la plantilla <code>11110xxx 10xxxxxx ...</code>:<ul> <li><code>11110</code><code>000</code> \\(\\to\\) <code>0xF0</code></li> <li><code>10</code><code>011111</code> \\(\\to\\) <code>0x9F</code></li> <li><code>10</code><code>011000</code> \\(\\to\\) <code>0x98</code></li> <li><code>10</code><code>000010</code> \\(\\to\\) <code>0x82</code></li> </ul> </li> </ol> </li> <li>Resultado final: <code>0xF0 0x9F 0x98 0x82</code>.</li> </ul> </li> </ol> <p>Por qu\u00e9 gan\u00f3 UTF-8</p> <ul> <li>Ahorro de espacio:<ul> <li>Ingl\u00e9s: Los textos cl\u00e1sicos (novelas, ensayos) y el c\u00f3digo fuente (HTML, Python, C++) contienen solo caracteres ASCII. En UTF-8 ocupan exactamente 1 byte por car\u00e1cter, igual que en los a\u00f1os 70.</li> <li>Espa\u00f1ol: La sobrecarga es m\u00ednima. En un texto normal (como El Quijote), solo las vocales acentuadas y la '\u00f1' ocupan 2 bytes. El 98% del texto (letras normales, espacios, puntuaci\u00f3n) sigue ocupando 1 byte. El aumento total de tama\u00f1o suele rondar apenas el 2%.</li> <li>Comparativa: Si us\u00e1ramos UTF-16, el archivo ocupar\u00eda el doble de tama\u00f1o, ya que cada letra (incluida la 'a' o el espacio) gastar\u00eda 2 bytes obligatoriamente.</li> </ul> </li> <li>Robustez: Es auto-sincronizado. Si se pierde un byte en la transmisi\u00f3n, es f\u00e1cil saber d\u00f3nde empieza el siguiente car\u00e1cter (todos los bytes de continuaci\u00f3n empiezan por <code>10...</code>).</li> </ul>"},{"location":"Representacion_de_la_informacion.html#otras-codificaciones-la-paradoja-del-uso","title":"Otras Codificaciones (La paradoja del uso)","text":"<p>Aunque UTF-8 domina internet y el almacenamiento en disco (lo que lo hace el m\u00e1s usado en volumen de datos), el concepto es relativo. Existen otras codificaciones que, por decisiones hist\u00f3ricas, dominan la memoria RAM de miles de millones de dispositivos:</p> <ul> <li>UTF-32: Usa siempre 4 bytes por car\u00e1cter. Es muy r\u00e1pido de procesar (acceso directo al car\u00e1cter en la posici\u00f3n N: salto \\(4 \\times N\\) bytes), pero desperdicia much\u00edsima memoria (un archivo de texto plano ocupa 4 veces m\u00e1s).</li> <li>UTF-16: El gigante silencioso. Usa 2 o 4 bytes.<ul> <li>\u00bfD\u00f3nde domina? En las entra\u00f1as de Windows, Java, JavaScript, .NET y, por herencia de Java, Android (aunque Android naci\u00f3 en los 2000).</li> <li>El problema: Windows y JavaScript se dise\u00f1aron en los a\u00f1os 90 creyendo que 2 bytes bastar\u00edan para todo. Android, aunque es posterior, hereda el uso de UTF-16 de Java. Hoy todos estos sistemas hablan UTF-16 internamente (en RAM) pero deben intercambiar datos en UTF-8 con el mundo exterior (Web/Red), pagando un precio en rendimiento por esa conversi\u00f3n continua.</li> <li>\u00bfY Apple/iPhone? Apple apost\u00f3 por UTF-8 en la mayor\u00eda de sus frameworks modernos (Core Foundation, Swift, etc.), as\u00ed que iOS y macOS no sufren la penalizaci\u00f3n de conversi\u00f3n constante: internamente y externamente usan UTF-8 casi siempre.</li> </ul> </li> </ul>"},{"location":"Representacion_de_la_informacion.html#cadenas-strings-en-programaci\u00f3n","title":"Cadenas (Strings) en Programaci\u00f3n","text":""},{"location":"Representacion_de_la_informacion.html#c_2","title":"C++","text":"<p>Siguiendo su filosof\u00eda de control sobre el hardware, C++ diferencia entre la unidad de almacenamiento y la codificaci\u00f3n.</p> <ul> <li><code>char</code>: Ocupa 1 byte. Literalmente almacena un entero de 8 bits.<ul> <li>Perfecto para ASCII.</li> <li>Peligro con UTF-8: Si almacenas <code>\"Espa\u00f1a\"</code> en un <code>std::string</code> (que es una secuencia de <code>char</code>), la <code>\u00f1</code> ocupar\u00e1 2 bytes. La funci\u00f3n <code>.length()</code> devolver\u00e1 7 bytes en lugar de 6 letras, y al acceder a <code>str[4]</code> obtendr\u00e1s solo la mitad de la <code>\u00f1</code>.</li> </ul> </li> <li>C++ moderno (C++11/20) introduce tipos como <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code> y literales <code>u8\"texto\"</code> para manejar Unicode expl\u00edcitamente, aunque es m\u00e1s complejo de usar que en lenguajes de alto nivel.</li> </ul>"},{"location":"Representacion_de_la_informacion.html#python_2","title":"Python","text":"<p>El lenguaje se encarga de la complejidad.</p> <ul> <li> <p>Python 3: El tipo <code>str</code> es Unicode por defecto: cada elemento de la cadena representa un s\u00edmbolo Unicode (un code point), pero la codificaci\u00f3n interna en memoria no es UTF-8, UTF-16 ni UTF-32 est\u00e1ndar. Desde Python 3.3, el lenguaje asocia cada s\u00edmbolo Unicode a una codificaci\u00f3n propia optimizada para ahorrar memoria, eligiendo 1, 2 o 4 bytes por car\u00e1cter seg\u00fan el contenido de la cadena.</p> <ul> <li>Si todos los caracteres caben en Latin-1 (ASCII + tildes b\u00e1sicas), usa 1 byte por car\u00e1cter.</li> <li> <p>Si hay alg\u00fan car\u00e1cter que necesita m\u00e1s, pero todos caben en el plano b\u00e1sico multiling\u00fce (BMP), usa 2 bytes por car\u00e1cter (como UTF-16). El plano b\u00e1sico multiling\u00fce (BMP) es el rango de Unicode de <code>U+0000</code> a <code>U+FFFF</code> (los primeros 65.536 s\u00edmbolos), donde est\u00e1n la mayor\u00eda de los alfabetos y s\u00edmbolos comunes del mundo.</p> </li> <li> <p>Si hay alg\u00fan car\u00e1cter raro (emojis, s\u00edmbolos hist\u00f3ricos, etc.), usa 4 bytes por car\u00e1cter (UTF-32).</p> </li> </ul> </li> </ul> <p>Diferencia Clave</p> <ul> <li>C++: Ve memoria. Una cadena es un array de bytes terminada en <code>\\0</code>.</li> <li>Python: Ve texto. Una cadena es una secuencia abstracta de s\u00edmbolos Unicode.</li> </ul> <p>&lt;!--</p>"},{"location":"Representacion_de_la_informacion.html#bytes-vs-str-y-archivos-de-textobinario-en-python","title":"Bytes vs. str y archivos de texto/binario en Python","text":"<p>En Python, es fundamental distinguir entre texto (tipo <code>str</code>) y datos binarios (tipo <code>bytes</code>).</p> <ul> <li>Un objeto <code>str</code> representa texto Unicode: cada elemento es un s\u00edmbolo abstracto, no un byte concreto. Ejemplo: <code>s = \"Espa\u00f1a\"</code>.</li> <li>Un objeto <code>bytes</code> representa datos binarios puros: una secuencia de valores entre 0 y 255. Ejemplo: una contrase\u00f1a segura generada aleatoriamente: <code>clave = bytes([137, 44, 255, ...])</code> (32 valores para 256 bits).</li> </ul> <p>\u00bfPor qu\u00e9 es importante?</p> <p>Si intentamos tratar una secuencia de bytes arbitrarios como si fuera texto, pueden aparecer s\u00edmbolos extra\u00f1os, errores o incluso p\u00e9rdida de informaci\u00f3n. Por ejemplo:</p> <p>```python</p>"},{"location":"Representacion_de_la_informacion.html#contrase\u00f1a-binaria-de-256-bits-32-bytes-aleatorios","title":"Contrase\u00f1a binaria de 256 bits (32 bytes aleatorios)","text":"<p>clave = bytes([137, 44, 255, 0, 18, 77, 201, 123, 88, 34, 190, 5, 222, 1, 99, 42,                17, 200, 33, 77, 250, 111, 0, 201, 100, 3, 77, 222, 11, 99, 42]) print(clave)  # Muestra: b'\\x89,\\xff\\x00\\x12M\\xc9{X\\\"\\xbe\\x05...'</p>"},{"location":"Representacion_de_la_informacion.html#si-intentamos-convertirla-a-texto-directamente","title":"Si intentamos convertirla a texto directamente:","text":"<p>try:     texto = clave.decode(\"utf-8\") except UnicodeDecodeError as e:     print(\"\u00a1Error al interpretar como texto!\", e)</p>"}]}