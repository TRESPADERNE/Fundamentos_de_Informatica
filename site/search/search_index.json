{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Fundamentos de Inform\u00e1tica","text":"<p>Grado en Ingenier\u00eda Biom\u00e9dica Departamento de Ingenier\u00eda de Sistemas y Autom\u00e1tica. EII. Universidad de Valladolid</p> <p>Bienvenido a la p\u00e1gina de apuntes de la asignatura. A continuaci\u00f3n encontrar\u00e1s el \u00edndice de los temas disponibles.</p>"},{"location":"#indice-de-temas","title":"\u00cdndice de Temas","text":""},{"location":"#bloque-i-introduccion","title":"Bloque I: Introducci\u00f3n","text":"<ul> <li>Tema 1: Lenguajes de Programaci\u00f3n<ul> <li>Conceptos b\u00e1sicos, clasificaci\u00f3n, compiladores vs int\u00e9rpretes.</li> </ul> </li> </ul>"},{"location":"Lenguajes_de_Programacion/","title":"FI_2: Lenguajes de Programaci\u00f3n","text":"<p>Fundamentos de Inform\u00e1tica Departamento de Ingenier\u00eda de Sistemas y Autom\u00e1tica. EII. Universidad de Valladolid</p>"},{"location":"Lenguajes_de_Programacion/#indice","title":"\u00cdndice","text":"<ol> <li>Introducci\u00f3n a los lenguajes de programaci\u00f3n</li> <li>Clasificaci\u00f3n</li> <li>Compiladores (Enfoque C++)</li> <li>Int\u00e9rpretes y M\u00e1quinas Virtuales</li> <li>Compiladores frente a Int\u00e9rpretes</li> <li>Ecosistema de Desarrollo (IDEs)</li> <li>Futuro de la Programaci\u00f3n</li> </ol>"},{"location":"Lenguajes_de_Programacion/#1-introduccion-a-los-lenguajes-de-programacion","title":"1. Introducci\u00f3n a los lenguajes de programaci\u00f3n","text":""},{"location":"Lenguajes_de_Programacion/#concepto-basico","title":"Concepto B\u00e1sico","text":"<p>Los programadores escriben programas utilizando lenguajes de programaci\u00f3n para que el ordenador ejecute una serie de instrucciones. Estos programas legibles por humanos se denominan c\u00f3digo fuente.</p> <p>Por otro lado, el ordenador (el hardware) trabaja internamente usando exclusivamente c\u00f3digo binario (secuencias de 0s y 1s que representan estados f\u00edsicos de voltaje), un formato que resulta ininteligible a primera vista para las personas. El c\u00f3digo binario ejecutable de un programa se denomina c\u00f3digo objeto o c\u00f3digo m\u00e1quina.</p> <p>Por tanto, se deduce la necesidad de utilizar programas traductores que conviertan el c\u00f3digo fuente (alto nivel de abstracci\u00f3n) a c\u00f3digo m\u00e1quina (bajo nivel de abstracci\u00f3n).</p>"},{"location":"Lenguajes_de_Programacion/#definicion-y-componentes","title":"Definici\u00f3n y Componentes","text":"<p>Un Lenguaje de Programaci\u00f3n es un conjunto de s\u00edmbolos y reglas con los que expresar \u00f3rdenes a un ordenador.</p> <ol> <li>L\u00e9xico: El conjunto de s\u00edmbolos (palabras, signos de puntuaci\u00f3n) que acepta el lenguaje.</li> <li>Sintaxis: Reglas que establecen qu\u00e9 construcciones son aceptables como instrucciones v\u00e1lidas (la gram\u00e1tica).</li> <li>Sem\u00e1ntica: Reglas que establecen el significado o comportamiento de dichas instrucciones.</li> </ol> <p>Diferencia clave entre Sintaxis y Sem\u00e1ntica: *   Ejemplo en lenguaje natural: La frase \"La silla come manzanas\"* es **sint\u00e1cticamente correcta (Sujeto + Verbo + Predicado), pero sem\u00e1nticamente incorrecta (carece de sentido l\u00f3gico). *   Ejemplo en programaci\u00f3n (Python): La insltrucci\u00f3n <code>resultado = \"Hola\" / 2</code> es sint\u00e1cticamente correcta (estructura v\u00e1lida: variable = valor / valor), pero sem\u00e1nticamente err\u00f3nea (no tiene sentido l\u00f3gico ni matem\u00e1tico dividir un texto (<code>\"Hola\"</code>) entre un n\u00famero (<code>2</code>).</p>"},{"location":"Lenguajes_de_Programacion/#comparativa-lenguaje-natural-vs-programacion","title":"Comparativa: Lenguaje Natural vs. Programaci\u00f3n","text":"Caracter\u00edstica Lenguaje Natural (Humano) Lenguaje de Programaci\u00f3n L\u00e9xico Palabras y signos de puntuaci\u00f3n. S\u00edmbolos reservados del lenguaje (palabras clave, operadores). Sintaxis Oraciones gramaticalmente correctas. Instrucciones bien formadas y v\u00e1lidas. Sem\u00e1ntica Informaci\u00f3n o mensaje que transmite quien habla. Qu\u00e9 acciones exactas debe ejecutar el hardware. Ambig\u00fcedad Alta (depende del contexto). Nula (una instrucci\u00f3n debe tener una \u00fanica interpretaci\u00f3n)."},{"location":"Lenguajes_de_Programacion/#2-clasificacion-niveles","title":"2. Clasificaci\u00f3n: Niveles","text":""},{"location":"Lenguajes_de_Programacion/#21-niveles-de-abstraccion","title":"2.1 Niveles de Abstracci\u00f3n","text":"<p>El concepto de abstracci\u00f3n en inform\u00e1tica se refiere a la capacidad de ocultar la complejidad interna del hardware para facilitar la programaci\u00f3n. Cuanto mayor es el nivel de abstracci\u00f3n de un lenguaje, m\u00e1s nos alejamos de los detalles f\u00edsicos de la m\u00e1quina (transistores, registros, direcciones de memoria) para centrarnos en la l\u00f3gica del problema a resolver (f\u00f3rmulas, objetos, datos).</p> <p>B\u00e1sicamente se pueden establecer tres niveles de abstracci\u00f3n: 1.  Lenguaje m\u00e1quina (Bajo nivel) 2.  Lenguaje ensamblador (Bajo nivel) 3.  Lenguajes de Alto nivel</p>"},{"location":"Lenguajes_de_Programacion/#lenguaje-maquina","title":"Lenguaje M\u00e1quina","text":"<p>Es el lenguaje directamente comprensible por el procesador (CPU). En el tema de Arquitectura estudiaremos c\u00f3mo la CPU procesa estas \u00f3rdenes; por ahora basta entender que es el componente hardware encargado de leer secuencialmente unos y ceros y actuar en consecuencia (sumar, guardar datos, etc.).</p> <ul> <li>Utiliza un sistema de codificaci\u00f3n binaria (secuencias de 1's y 0's) para definir un conjunto predefinido de instrucciones, (ISA, Instruction Set Architecture).     &gt; Una instrucci\u00f3n es la operaci\u00f3n m\u00e1s elemental que el hardware puede realizar indivisiblemente, como sumar dos valores, mover un dato de memoria al procesador, etc.</li> <li>Depende totalmente de la arquitectura: un c\u00f3digo m\u00e1quina para una CPU ARM (m\u00f3vil) es incomprensible para una CPU Intel Core i7 (PC).</li> <li>Gesti\u00f3n: A este nivel, el control de la memoria es manual y absoluto.     &gt; La memoria es el casillero gigante de celdas numeradas donde se almacenan los datos y el programa en ejecuci\u00f3n. En c\u00f3digo m\u00e1quina no existen las variables con nombres (como <code>edad</code>), sino que el programador debe referirse a los datos por su direcci\u00f3n f\u00edsica (el n\u00famero exacto de la celda, ej: <code>0x0045A</code>).</li> </ul>"},{"location":"Lenguajes_de_Programacion/#lenguaje-ensamblador","title":"Lenguaje Ensamblador","text":"<p>Emplea palabras nemot\u00e9cnicas (abreviaturas) para hacer referencia a las instrucciones del lenguaje de m\u00e1quina, haci\u00e9ndolo ligeramente m\u00e1s legible para el humano.</p> <p>Ejemplo de traducci\u00f3n y estructura (Familia x86/IA-32):</p> Lenguaje de m\u00e1quina Ensamblador <code>10110000 01100001</code> <code>MOV AL, 61h</code> <p>En este ejemplo, la instrucci\u00f3n binaria se compone de 3 partes que el hardware decodifica: 1.  C\u00f3digo de operaci\u00f3n (5 primeros bits): La secuencia <code>10110</code> ordena mover (MOV) un dato a un registro.     &gt; Nota: Un registro es una posici\u00f3n de memoria ultrarr\u00e1pida situada dentro de la propia CPU. 2.  Registro destino (3 siguientes bits): El c\u00f3digo <code>000</code> corresponde al registro interno denominado AL. 3.  Dato (8 bits finales): La secuencia <code>01100001</code> es el valor del dato (97 en decimal, 61 en hexadecimal).</p> <p>El lenguaje ensamblador permite escribir <code>MOV AL, 61h</code> en lugar de la cadena de bits, resultando mucho m\u00e1s inteligible.</p> <p>Proceso de Traducci\u00f3n: El programa escrito en lenguaje ensamblador (Programa Fuente) debe ser traducido a lenguaje de m\u00e1quina (Programa Objeto), ya que el procesador solo entiende 0s y 1s. Esta tarea la realiza una herramienta llamada Ensamblador.</p> <p><code>[Programa Fuente] --&gt; [Ensamblador] --&gt; [Programa Objeto]</code></p> <p>Caracter\u00edsticas clave: *   Traducci\u00f3n directa: Generalmente existe una correspondencia 1 a 1 entre instrucci\u00f3n ensamblador y m\u00e1quina. *   Dependencia: \u00a1Cada familia de CPU's tiene su propio lenguaje ensamblador!</p>"},{"location":"Lenguajes_de_Programacion/#lenguajes-de-alto-nivel","title":"Lenguajes de Alto Nivel","text":"<p>Estos lenguajes buscan acercarse a la forma de pensar humana y alejarse del detalle del hardware.</p> <ul> <li>Independencia y Portabilidad: Definen su sintaxis y sus estructuras al margen del procesador que se utilice. Un mismo c\u00f3digo fuente puede ejecutarse en diferentes m\u00e1quinas (es portable), siempre que se traduzca adecuadamente.</li> <li>Correspondencia Compleja (1 a N): A diferencia del ensamblador (1 a 1), una sola sentencia de alto nivel genera m\u00faltiples instrucciones de c\u00f3digo m\u00e1quina.</li> <li>Legibilidad y Edici\u00f3n: Se escriben como texto plano (usando palabras en ingl\u00e9s como <code>if</code>, <code>while</code>) y permiten el uso de comentarios para explicar el c\u00f3digo a otros humanos.</li> <li>Necesidad de Traducci\u00f3n: Para poder ejecutarse, necesitan ser traducidos al lenguaje del procesador mediante Compiladores o Int\u00e9rpretes.</li> <li>Tipado:<ul> <li>Est\u00e1tico (C++, Java): El tipo de dato debe definirse expl\u00edcitamente antes de compilar.     &gt; Ejemplo: <code>int x = 3;</code> (El programador obliga a que <code>x</code> sea un n\u00famero entero).</li> <li>Din\u00e1mico (Python, JS): El tipo se deduce autom\u00e1ticamente durante la ejecuci\u00f3n.     &gt; Ejemplo: <code>x = 3</code> (Python infiere que <code>x</code> es un entero por el valor asignado, sin necesidad de declararlo).</li> </ul> </li> </ul>"},{"location":"Lenguajes_de_Programacion/#ejemplo-comparativo-hola-mundo","title":"Ejemplo Comparativo: \"Hola Mundo\"","text":"<p>Para visualizar la diferencia de abstracci\u00f3n, veamos c\u00f3mo se imprime un mensaje en pantalla en distintos niveles:</p> Nivel C\u00f3digo Ejemplo Lenguaje M\u00e1quina <code>B8 21 0A 00 00 ...</code> (Secuencia binaria/hexadecimal ininteligible) Ensamblador (x86) <code>MOV EDX, len</code><code>MOV ECX, msg</code><code>MOV EBX, 1</code><code>MOV EAX, 4</code><code>INT 0x80</code> C++ (Alto Nivel) <code>std::cout &lt;&lt; \"Hola Mundo\";</code> Python (Muy Alto Nivel) <code>print(\"Hola Mundo\")</code>"},{"location":"Lenguajes_de_Programacion/#paradigmas-de-programacion","title":"Paradigmas de programaci\u00f3n","text":"<p>Un paradigma de programaci\u00f3n describe una forma de realizar los c\u00e1lculos y la manera en que se deben estructurar y organizar las tareas que debe llevar a cabo un programa.</p> <ul> <li>Los lenguajes de programaci\u00f3n suelen implementar, a menudo de forma parcial, varios paradigmas.</li> <li>Entre los diferentes tipos de paradigmas, una divisi\u00f3n b\u00e1sica es dividirlos en imperativos (se detalla c\u00f3mo se realizan los c\u00e1lculos) y declarativos (se indica qu\u00e9 c\u00e1lculos deben realizarse).</li> <li>Otros paradigmas se centran en la estructura y organizaci\u00f3n: programaci\u00f3n estructurada, modular, orientada a objetos, gen\u00e9rica, orientada a eventos, concurrente...</li> </ul> <p>Nota: La mejor forma de entender un paradigma es aprender un lenguaje de programaci\u00f3n que implemente ese paradigma, por lo que no entraremos por el momento en m\u00e1s detalles.</p> <p> Clasificaci\u00f3n de los paradigmas de programaci\u00f3n. </p>"},{"location":"Lenguajes_de_Programacion/#la-jungla-de-los-lenguajes","title":"La jungla de los lenguajes","text":"<p>A menudo, el panorama actual se percibe como una jungla de lenguajes. *   Existen miles de lenguajes (se estima que hay m\u00e1s de 9.000 creados hist\u00f3ricamente). *   Para un alumno novel, enfrentarse a esta imagen provoca la par\u00e1lisis de la elecci\u00f3n: \u00bfPor cu\u00e1l empiezo? \u00bfCu\u00e1l es el *mejor?* *   La realidad: No todos tienen la misma importancia. Muchos son acad\u00e9micos, otros est\u00e1n obsoletos (como el lat\u00edn) y otros son de nicho muy espec\u00edfico.</p> <p>En esa jungla encontrar\u00e9is herramientas para todo. Python es una navaja suiza (sirve para casi todo, f\u00e1cil de llevar), C++ es un bistur\u00ed l\u00e1ser industrial (muy potente, pero si no sabes usarlo te cortas un brazo), y otros son simplemente juguetes.</p> <p> La jungla de lenguajes de programaci\u00f3n. </p> <p> \u00bfQu\u00e9 lenguaje aprender en primer lugar? </p> <p> Ranking Redmonk </p> <p> Ranking TIOBE </p>"},{"location":"Lenguajes_de_Programacion/#por-que-python-como-primer-lenguaje-en-ingenieria","title":"\u00bfPor qu\u00e9 Python como primer lenguaje en Ingenier\u00eda?","text":"<p>Dado que nuestra asignatura se orienta a titulaciones de ingenier\u00eda (Biom\u00e9dica, Electr\u00f3nica, Mec\u00e1nica, Qu\u00edmica...), la elecci\u00f3n de Python como primer lenguaje no es arbitraria y se justifica por varios motivos t\u00e9cnicos y pr\u00e1cticos frente a opciones cl\u00e1sicas como C o C++:</p> <ol> <li> <p>Foco en la resoluci\u00f3n del problema: En ingenier\u00eda, la programaci\u00f3n es una herramienta para resolver problemas (filtrar una se\u00f1al fisiol\u00f3gica, simular una estructura mec\u00e1nica, analizar datos qu\u00edmicos), no un fin en s\u00ed mismo. La sintaxis de Python es limpia y legible (cercana al pseudoc\u00f3digo), lo que reduce la carga cognitiva: el alumno dedica su esfuerzo mental a entender el algoritmo, no a pelear con llaves, puntos y comas o gesti\u00f3n de memoria manual.</p> </li> <li> <p>El est\u00e1ndar en Ciencia de Datos e IA: Python posee el ecosistema de librer\u00edas cient\u00edficas m\u00e1s robusto del mundo.</p> <ul> <li>Biom\u00e9dica: Procesamiento de im\u00e1genes (OpenCV), se\u00f1ales m\u00e9dicas (SciPy, MNE).</li> <li>Mec\u00e1nica/Qu\u00edmica: An\u00e1lisis de datos experimentales (Pandas), simulaci\u00f3n num\u00e9rica (NumPy).</li> <li>Electr\u00f3nica: Control de instrumentos y automatizaci\u00f3n.</li> </ul> </li> <li> <p>Productividad: Un programa en Python suele requerir entre 3 y 5 veces menos l\u00edneas de c\u00f3digo que su equivalente en C++ o Java. Esto permite prototipar soluciones funcionales en mucho menos tiempo.</p> </li> <li> <p>Multiparadigma: Permite empezar programando de forma imperativa (sencilla) y avanzar hacia la orientaci\u00f3n a objetos o funcional progresivamente, sin imponer una estructura r\u00edgida desde la l\u00ednea 1.</p> </li> </ol>"},{"location":"Lenguajes_de_Programacion/#3-compiladores-el-modelo-cc","title":"3. Compiladores (El modelo C/C++)","text":"<p>Un compilador es un programa que traduce todo el c\u00f3digo fuente de una sola vez a un programa equivalente en otro lenguaje (normalmente c\u00f3digo m\u00e1quina) para su posterior ejecuci\u00f3n.</p> <p>Nota: El compilador detecta errores en tiempo de compilaci\u00f3n (sintaxis), pero no errores en tiempo de ejecuci\u00f3n (l\u00f3gica).</p>"},{"location":"Lenguajes_de_Programacion/#proceso-de-compilacion-en-c","title":"Proceso de compilaci\u00f3n en C++","text":"<ol> <li>Edici\u00f3n: Se escribe el c\u00f3digo fuente: las extensiones de los archivos t\u00edpicos son <code>.cpp</code> y <code>.h</code>.</li> <li>Preprocesamiento: Es una fase previa de preparaci\u00f3n del texto. El preprocesador limpia el c\u00f3digo eliminando las notas del autor (comentarios) e incrusta el contenido de ficheros externos necesarios (como si hiciera un copiar y pegar autom\u00e1tico de las bibliotecas), dejando el c\u00f3digo listo para traducir.</li> <li>Compilaci\u00f3n: Traduce el c\u00f3digo preprocesado a c\u00f3digo objeto (<code>.o</code> o <code>.obj</code>). Este c\u00f3digo es binario pero a\u00fan no es ejecutable por s\u00ed mismo porque le faltan las conexiones con el resto del proyecto.     &gt; Un programa suele dividirse en muchos archivos fuente. En esta fase, cada archivo se traduce por separado, pero si uno necesita usar una funci\u00f3n que est\u00e1 escrita en otro archivo, todav\u00eda no sabe d\u00f3nde encontrarla. Esas referencias cruzadas est\u00e1n pendientes de resolver.</li> <li>Enlazado (Linker): Une todos los archivos objeto del programador con las bibliotecas externas (ej. funciones matem\u00e1ticas) para crear un \u00fanico fichero ejecutable binario (<code>.exe</code>).</li> </ol> <p><code>[INSERTAR FIGURA: Diagrama de flujo Preprocesador -&gt; Compilador -&gt; Enlazador]</code></p>"},{"location":"Lenguajes_de_Programacion/#etapas-internas-del-compilador","title":"Etapas internas del compilador","text":"<p>El compilador realiza la traducci\u00f3n t\u00edpicamente en 2 grandes fases:</p> <ol> <li>Fase de An\u00e1lisis (Front-end):<ul> <li>L\u00e9xico: Verifica s\u00edmbolos v\u00e1lidos.</li> <li>Sint\u00e1ctico: Verifica la estructura gramatical.</li> <li>Sem\u00e1ntico: Verifica la coherencia de tipos y significado.</li> </ul> </li> <li>Fase de S\u00edntesis (Back-end):<ul> <li>Generaci\u00f3n de c\u00f3digo intermedio.</li> <li>Optimizaci\u00f3n: Fase cr\u00edtica donde el compilador mejora el c\u00f3digo (elimina c\u00f3digo muerto, desenrolla bucles) para reducir tama\u00f1o o aumentar velocidad.</li> <li>Generaci\u00f3n de c\u00f3digo m\u00e1quina espec\u00edfico para la arquitectura.</li> </ul> </li> </ol>"},{"location":"Lenguajes_de_Programacion/#4-interpretes-y-maquinas-virtuales","title":"4. Int\u00e9rpretes y M\u00e1quinas Virtuales","text":""},{"location":"Lenguajes_de_Programacion/#interprete-puro","title":"Int\u00e9rprete Puro","text":"<p>A diferencia del compilador, el int\u00e9rprete lee, traduce y ejecuta el c\u00f3digo fuente l\u00ednea a l\u00ednea (o bloque a bloque) en tiempo real. *   No genera un ejecutable independiente. *   Ventaja: Flexibilidad, depuraci\u00f3n r\u00e1pida, tipado din\u00e1mico. *   Desventaja: Menor velocidad de ejecuci\u00f3n (se traduce cada vez que se ejecuta).</p>"},{"location":"Lenguajes_de_Programacion/#modelo-hibrido-maquinas-virtuales","title":"Modelo H\u00edbrido: M\u00e1quinas Virtuales","text":"<p>Muchos lenguajes modernos (Java, Python, C#) utilizan un esquema intermedio. 1.  El c\u00f3digo fuente se compila a un C\u00f3digo Intermedio o Bytecode (ej. <code>.class</code> en Java, <code>.pyc</code> en Python). Este c\u00f3digo es universal y no depende de la CPU. 2.  Una M\u00e1quina Virtual (VM) instalada en el ordenador del usuario interpreta ese Bytecode y lo traduce a c\u00f3digo m\u00e1quina nativo.</p> <p><code>[INSERTAR FIGURA: Comparativa flujo Compilador vs Int\u00e9rprete]</code></p> <p>Ventajas de la M\u00e1quina Virtual: *   Portabilidad (WORA): \"Write Once, Run Anywhere\". El mismo bytecode corre en Windows, Linux o Mac, siempre que exista la VM correspondiente. *   Seguridad: La VM act\u00faa como una caja de arena (sandbox), aislando el c\u00f3digo del hardware real. *   Gesti\u00f3n de Memoria: La mayor\u00eda de VMs incluyen un Recolector de Basura (Garbage Collector) que libera memoria autom\u00e1ticamente, evitando fugas de memoria comunes en C++.</p> <p>Compilaci\u00f3n JIT (Just-In-Time): Para mejorar el rendimiento, las VMs modernas (como la JVM de Java o V8 de JS) compilan trozos de bytecode a c\u00f3digo nativo mientras el programa se ejecuta, combinando la velocidad de un compilado con la flexibilidad de un interpretado.</p> <p>Ejemplos: *   Java: Usa la JVM (Java Virtual Machine). *   Python: Usa la PVM. *   .NET (C#): Compila a CIL (Common Intermediate Language) y lo ejecuta el CLR (Common Language Runtime).</p>"},{"location":"Lenguajes_de_Programacion/#5-compiladores-frente-a-interpretes-resumen","title":"5. Compiladores frente a Int\u00e9rpretes (Resumen)","text":"<p>A continuaci\u00f3n, comparamos los enfoques principales: Compilaci\u00f3n Pura (C++), Interpretaci\u00f3n Pura (versiones antiguas de BASIC, Scripts de Shell) y Enfoque H\u00edbrido/VM (Java, Python).</p> Caracter\u00edstica Compilador Nativo (C++) Int\u00e9rprete Puro M\u00e1quina Virtual (Java/Python) Proceso Fuente \\(\\to\\) M\u00e1quina (Ejecutable) Fuente \\(\\to\\) Ejecuci\u00f3n directa Fuente \\(\\to\\) Bytecode \\(\\to\\) VM Cu\u00e1ndo se traduce Antes de ejecutar (tiempo de compilaci\u00f3n). Durante la ejecuci\u00f3n (tiempo real). Mixto (pre-compilaci\u00f3n a bytecode + JIT). Rendimiento Muy Alto. Optimizado para el hardware espec\u00edfico. Bajo. Sobrecarga por traducci\u00f3n constante. Medio/Alto. Gracias a tecnolog\u00edas JIT. Privacidad C\u00f3digo Alta (se entrega binario dif\u00edcil de leer). Nula (se entrega c\u00f3digo fuente visible). Media (se entrega bytecode, que es reversible). Portabilidad Baja. Requiere recompilar para cada SO. Alta. Solo requiere el int\u00e9rprete instalado. Muy Alta (WORA). Bytecode universal. Detecci\u00f3n Errores Todos los de sintaxis reportados antes de correr. El programa se detiene al encontrar el primer error. Errores de sintaxis al generar bytecode; l\u00f3gica en ejecuci\u00f3n. <p><code>[INSERTAR FIGURA: Esquema \u00e1rbol Compilaci\u00f3n vs VM]</code></p>"},{"location":"Lenguajes_de_Programacion/#6-ecosistema-de-desarrollo-ides","title":"6. Ecosistema de Desarrollo (IDEs)","text":"<p>Programar en un simple editor de texto (como el Bloc de Notas) es posible, pero ineficiente. Los profesionales usan IDEs (Integrated Development Environment), que combinan m\u00faltiples herramientas en una sola interfaz:</p> <ol> <li>Editor de c\u00f3digo: Con resaltado de sintaxis y autocompletado automatizado.</li> <li>Compilador/Int\u00e9rprete integrado: Para ejecutar el programa con un solo clic.</li> <li>Depurador (Debugger): Herramienta vital que permite detener la ejecuci\u00f3n paso a paso para inspeccionar variables y encontrar errores l\u00f3gicos.</li> <li>Gesti\u00f3n de proyectos: Organizaci\u00f3n de ficheros y control de versiones (Git).</li> </ol> <p>Ejemplos populares: Visual Studio Code (ligero y multiprop\u00f3sito), Eclipse/IntelliJ (Java), Visual Studio (C++/C#), PyCharm (Python).</p>"},{"location":"Lenguajes_de_Programacion/#7-futuro-de-la-programacion","title":"7. Futuro de la Programaci\u00f3n","text":"<p>La forma en que programamos est\u00e1 en constante evoluci\u00f3n: *   Asistentes de IA: Herramientas como GitHub Copilot generan c\u00f3digo autom\u00e1ticamente a partir de descripciones en lenguaje natural, cambiando el rol del programador de \"escritor\" a \"supervisor\". *   Low-Code / No-Code: Plataformas visuales para crear aplicaciones sin escribir c\u00f3digo manual, democratizando el desarrollo. *   Computaci\u00f3n Cu\u00e1ntica: Nuevos paradigmas y lenguajes (como Q# de Microsoft) dise\u00f1ados para operar con qubits, resolviendo problemas inabordables para la inform\u00e1tica cl\u00e1sica.</p>"},{"location":"Lenguajes_de_Programacion/#bibliografia-y-referencias","title":"Bibliograf\u00eda y Referencias","text":"<ul> <li>M. Franklin. Computer Architecture and Organization. From Software to Hardware. Pearson 2007.</li> <li>Documentaci\u00f3n oficial de C++ (cppreference.com) y Python (docs.python.org).</li> <li>TIOBE Index &amp; IEEE Spectrum (Rankings de lenguajes).</li> </ul>"}]}